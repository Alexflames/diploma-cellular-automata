\documentclass[bachelor, och, diploma, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{longtable}
\usepackage{array}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[english,russian]{babel}

\usepackage[colorlinks=true]{hyperref}

\lstset{%
  language=[Sharp]C,
  basicstyle=\small,
  tabsize = 2,
  breaklines=true,
  columns=fullflexible
}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Оптимизации поиска приближенных решений в эволюционирующих клеточных автоматах}

% Курс
\course{4}

% Группа
\group{451}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Григорьева Алексея Александровича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н., доцент} % степень, звание
\chname{А.\,С.\,Иванов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент} %должность, степень, звание
\saname{М.\,С.\,Семенов}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{доцент}
\paname{М.\,С.\,Семенов}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{8}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{преддипломная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{4}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{30.04.2020}
\practFinish{27.05.2020}

% Год выполнения отчета
\date{2020}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations
%\begin{description}
    %\item \foreignlanguage{english}{EVM} "--- %\foreignlanguage{english}{Ethereum Virtual Machine};
%\end{description}

% Раздел "Определения". Может отсутствовать в работе
%\definitions
%Паттерн "--- целевое изображение, воспроизведение которого должно быть достигнуто клеточным автоматом.

%Эксперимент (в контексте данной работы) "--- процесс поэтапной эволюции клеточных автоматов с целью достижения максимального совпадения воспроизводимых ими результатов заданным наперед паттернам.

%Сетка "--- двумерная регулярная решетка ячеек.


% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro
Клеточный автомат "--- дискретная модель, изучаемая теорией автоматов~\cite{automata}. В общем случае, клеточный автомат состоит из регулярной решетки ячеек, множества состояний, множества входных сигналов и функции перехода. Клеточные автоматы применяются в компьютерном зрении~\cite{edge-detection}, криптографии~\cite{crypto}, компьютерной графике\cite{cgraphics} и при моделировании различных процессов: физических~\cite{physics}, химических~\cite{chemistry}, биологических~\cite{bio}. Одним из наиболее известных является клеточный автомат "--- игра <<Жизнь>>~\cite{conways}.

Существует огромное количество конфигураций клеточных автоматов. Меняя число возможных состояний, правила подсчета входных сигналов, возможные начальные состояния, получаются новые множества автоматов, перебор которых невозможен с текущими вычислительными мощностями. Поэтому для поиска клеточных автоматов, удовлетворяющих каким-либо условиям, используют алгоритмы нахождения приближенного результата. В недавних работах на схожую тему применялись генетические алгоритмы~\cite{genetic-first} и нейронные сети~\cite{mordvintsev2020growing}.
В настоящей работе перебор осуществляется с использованием генетических алгоритмов. 

В основе работы лежит выполнение экспериментов по нахождению приближенного решения клеточными автоматами.
Цель каждого эксперимента "--- стабильное выполнение заданных условий ячейками, полученными после работы клеточных автоматов из множества начальных состояний. В данной работе начальное состояние задано случайно в каждой ячейке автомата.
Для наглядности в качестве цели, которая будет поставлена перед началом экспериментов, будет воспроизведение заданного наперед целевого изображения (паттерна). Благодаря этому можно будет не только полагаться на полученные числовые значения, но и сопоставить результат с визуализацией в приложении. После каждого эксперимента должна сохраняться исчерпывающая информация о поведении клеточного автомата. По ней должно быть возможно определить конфигурацию автомата, генетического алгоритма, был ли удачным эксперимент и сколько было затрачено времени.

Эксперименты по оптимизации проводились для двумерных клеточных автоматов первого порядка, с возможными состояниями 0 и 1. Следующее состояние ячейки клеточного автомата определяется 9 соседними ячейками на решетке включая данную или, другими словами, окрестностью Мура порядка 2~\cite{moore}. 
Тип автоматов выбран не случайно: количество всевозможных правил равно $2^{512}$~\cite{twodimensional},
что гарантирует невозможность перебора. %ссылка на переборы?, лол
Более того, не существует и общего аналитического решения для воспроизведения автоматами произвольного изображения, при условии что изначальная двумерная сетка задана случайными значениями.
У выбранных в данной работе типов клеточных автоматов также есть преимущества, связанные с возможностью оптимизации алгоритмов с использованием быстрых побитовых операций~\cite{bithacks-perf}. %слегка косяк ибо следующее предложение немного не связано с этим, но намекает собой на это
Многие из описанных далее результатов возможно перенести на случай клеточных автоматов \verb|N|-го порядка~\cite{higherorder}, % так ли это? Если да, нужно цитировать
а также для клеточных автоматов с увеличенным количеством состояний или иными правилами переходов.

Целью настоящей работы является исследование возможностей по оптимизации поиска приближенного решения на основе паттернов двумерными клеточными автоматами первого порядка при помощи генетического алгоритма. Для достижения этой цели необходимо:
\begin{enumerate}
\item разработать гибкое приложение, моделирующее работу клеточных автоматов с возможностью конфигурации генетического алгоритма;
\item добавить визуализацию клеточных автоматов и сбор статистики по экспериментам;
\item провести множество экспериментов с различными конфигурациями и целевыми изображениями;
\item сделать выводы, определить лучшие параметры генетического алгоритма, предложить возможные оптимизации.
\end{enumerate}

\section{Окружение для проведения экспериментов}
В данном разделе приведено описание проекта и вспомогательных функций для моделирования и визуализации двумерных клеточных автоматов первого порядка. 

\subsection{Среда разработки}
Программа для моделирования и визуализации клеточных автоматов выполнена в среде разработки \verb|Unity 2019.2.21f|. Выбор среды разработки обоснован следующими удобствами:
\begin{itemize}
\item быстрая и многофункциональная работа с графикой посредством готовых функций и визуального проектирования;
\item профессиональные инструменты для отладки и профилирования производительности программы;
\item наглядность результата программы.
\end{itemize}

Программный код написан на языке \verb|C#|. Основная логика экспериментов реализована в сцене \foreignlanguage{English}{MainScene}. Весь проект подключен к системе контроля версий %можно сослаться либо на систему контроля версий
Git~\cite{git} на базе популярного ресурса для хранения версий Github. Ссылка на <<репозиторий>>: \url{https://github.com/Alexflames/cellular-automation}. % либо на гитхаб

Со структурой проекта можно ознакомиться в приложении~\ref{filesystem}.


\subsection{Реализация клеточного автомата}
Каждый клеточный автомат представляется ячейками на двумерной сетке. %упомянуть периодичные граничные условия 
Для прозрачности процесса и наглядности результатов, эксперимент проводится полностью в реальном времени: в каждую единицу времени все ячейки автоматов на всех сетках переходят в новое состояние, определенное входными сигналами и правилами перехода.

Опишем правила перехода для двумерного клеточного автомата первого порядка. При подсчете входного сигнала в ячейке автомата будут учитываться как и состояние данной ячейки, 
так и состояния восьми соседних ячеек в окрестности Мура порядка 2, для подсчета берутся значения с последней итерации. Возьмем самый простой случай: автомат может принимать значения 0 и 1. Таким образом, возможны $2^9=512$ вариантов входных сигналов. Отсюда и берется упомянутое ранее количество всевозможных правил для данных клеточных автоматов, равное $2^{512}$.

В качестве визуализации клеточных автоматов в \verb|Unity| можно использовать шейдеры. Плюс этого подхода заключается в том, что компьютер не будет тратить ресурсы оперативной памяти для визуализации автоматов, и вся нагрузка на это отдается видеокарте, находящейся большую часть времени в простое. Шейдеры позволяют создавать крупные визуализации огромной размерности благодаря эффективным вычислениям на видеокарте~\cite{gpu-performance}. 

\subsubsection{Правило перехода} \label{simple-update}
Создадим простейшую реализацию подсчета входных сигналов для ячеек в клеточном автомате. 
Для избежания лишних затрат памяти, в основной части программы заранее созданы массивы для временного хранения следующих состояний ячеек автомата. Это необходимо, чтобы полученный результат не влиял на соседние ячейки в данный момент времени.

Создадим цикл, который будет выполняться на двумерной сетке клеточных автоматов размерностью \verb|screenSizeInPixels| по X и Y.
\begin{minted}[fontsize=\footnotesize]{csharp}
	var nextCAField = nextVirtualScreens[ind];
	var screen2DSize = screenSizeInPixels * screenSizeInPixels;
	for (short i = 0; i < screenSizeInPixels; i++)
	{
	   for (short j = 0; j < screenSizeInPixels; j++)
	   {
	       int signal = 0;
	       for (short k = 0; k < 3; k++)
	       {
	           for (short m = 0; m < 3; m++)
	           {
	               signal += CAField[
	                   (screen2DSize + screenSizeInPixels * i + j
	                   + screenSizeInPixels * (k - 1) + (m - 1)) 
	                   % (screen2DSize)] << (k * 3 + m);
	           }
	       }
	       nextCAField[i * screenSizeInPixels + j] = (byte)allRules[ind][signal];
	   }
	}
	
	for (short i = 0; i < screen2DSize; i++)
	{
	   CAField[i] = nextCAField[i];
	}
\end{minted}

\subsubsection{Оптимизированное вычисление входных сигналов} \label{signal-optimized}
Заметим, что в вычислении следующего состояния каждого автомата используется 9 обращений к сетке. Более того, при каждом последующем обращении к сетке после первого, повторно считываются 6 состояний. Представим квадрат $3\times3$, окрестность Мура порядка 2, в виде окна, которое можно сдвигать вправо по сетке. Разобьем окно на 3 горизонтальные буфер-линии и, при переходе в новое состояние (аналогично сдвигу окна вправо), будем считывать лишь 3 новых бита справа. Добавление каждого бита в строку-буфер сопровождается побитовым сдвигом строки на 1 влево с отсечением крайнего левого бита. Сигналом для текущего автомата будет сумма верхней строки, средней строки с побитовым сдвигом влево на 3 и нижней строки с побитовым сдвигом на 6. Для наглядности процесс изображен на рисунке~\ref{opt-pattern}. 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{images/opti-pattern}
	\caption{Принцип оптимизированного вычисления входных сигналов с использованием буферов и побитовых сдвигов.}\label{opt-pattern}
\end{figure}

Результат аналогичен тому, что было получено в предыдущем разделе~\ref{simple-update}, но будет требоваться примерно в 3 раза меньше операций доступа. Полученная оптимизация особенно важна для нас, ведь обновление всех автоматов происходит каждый кадр. Полный код новой функции можно посмотреть в приложении \ref{code-update-optimised}.
% на самом деле это немного не так, но может опустить подробности 

\subsubsection{Правило перехода на языке шейдеров (HLSL)}
Обновление клеточных автоматов возможно полностью перенести в шейдеры. Каждая сетка с клеточным автоматом будет использовать свою текстуру и шейдер.

Для написания правила перехода на языке шейдеров необходимо решить три проблемы:
\begin{enumerate}
\item получение информации о состояниях в предыдущий момент времени;
\item соотнесение представления в битах (пикселях) с текстурой в трехмерном пространстве;
\item обновление шейдера только при необходимости.
\end{enumerate}

Возьмем \verb|Custom Render Texture| из среды разработки \verb|Unity|. Данная текстура создана для того, чтобы её можно было обновлять с помощью шейдеров. 
%https://docs.unity3d.com/Manual/class-CustomRenderTexture.html 
% настройки
Первая проблема решается расширением языка HLSL, предоставляемым \verb|Custom Render Texture|. В фрагментном шейдере можно обратиться к переменной \verb|localTexcoord|, в которой хранится состояние текстуры на предыдущий момент отрисовки.

Вторая проблема также решается с использованием глобальных переменных: \verb|_CustomRenderTextureWidth|, предоставляющая реальную ширину объекта в пространстве, и \verb|_CustomRenderTextureHeight|, возвращающая высоту текстуры.

Определим настройки \verb|Custom Render Texture| (рис.~\ref{CRT}). Установка параметра \verb|Wrap Mode| в значение \verb|Repeat| задаст периодические граничные условия для сетки. Другими словами, при обращении к пикселям по координатам, превышающим размерность текстуры, будут взяты пиксели с противоположной стороны сетки. Создадим пустой шейдер, код для которого опишем дальше. Настройка \verb|Update Mode| в значение \verb|On Demand| позволяет обновлять состояние текстуры по вызову функции из основной программы, что позволит получить полный контроль над обновлением автоматов.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{images/CustomRendererTexture}
	\caption{Настройка Custom Render Texture.}\label{CRT}
\end{figure}

% https://thebookofshaders.com/03/?lan=ru
В шейдерое определим uniform-переменную: таблицу переходов размерности 512 (все возможные состояния рассматриваемого клеточного автомата).
\begin{minted}[fontsize=\footnotesize]{glsl}
	float _rule[512];
\end{minted}

Опишем функцию, возвращающую значение пикселя с заданным отступом в сетке относительно текущего клеточного автомата.
\begin{minted}[fontsize=\footnotesize]{glsl}
	float4 get(v2f_customrendertexture IN, int x, int y) : COLOR
	{
	   return tex2D(_SelfTexture2D, IN.localTexcoord.xy + 
	   	 fixed2(x / _CustomRenderTextureWidth, y / _CustomRenderTextureHeight));
	}
\end{minted}

Аналогично построению двоичного числа, последовательно, с левого верхнего угла, соберем биты входных сигналов для клеточного автомата в окрестности Мура порядка 2 и получим следующее состояние из таблицы переходов. Данный код необходимо выполнять в фрагментном шейдере~\cite{shader-pipeline}

\begin{minted}[fontsize=\footnotesize]{glsl}
	float getRule9(v2f_customrendertexture IN) : float
	{
	   int accumulator = 0;
	   for (int i = 2; i >= 0; i--) 
	   {
	       for (int j = 0; j <= 2; j++) 
	       {
	           int roundedAlpha = round(get(IN, i-1, j-1).a);
	           accumulator = (accumulator << 1) + roundedAlpha;
	       }
	   }
	   return _rule[accumulator];
	}
	
	float4 frag(v2f_customrendertexture IN) : COLOR
	{
	   return getRule9(IN);
	}
\end{minted}

Осталось объединить шейдер с основной программой. Пусть в массиве \verb|allRules| находятся правила для всех клеточных автоматов. Тогда, 
опуская подробности, инициализацию текстуры можно произвести с помощью следующего кода

\begin{minted}[fontsize=\footnotesize]{csharp}
	customRenderTexture.material.SetFloatArray("_rule", allRules[screenInd]);
	customRenderTexture.Initialize();
\end{minted}

Пусть в массиве \verb|custormRenderTextures| содержатся все текстуры (сетки). Тогда, обновить каждый автомат можно, используя следующий фрагмент кода:

\begin{minted}[fontsize=\footnotesize]{csharp}
	foreach(var texture in customRenderTextures)
	{
	   texture.Update();
	}
\end{minted}

Запустим программу и увидим клеточные автоматы в динамике, как изображено на рис.~\ref{shvis}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{images/Shader-visualisation-2}
	\includegraphics[scale=0.7]{images/Shader-visualisation-1}
	\caption{Визуализация клеточных автоматов.}\label{shvis}
\end{figure}

\section{Генетический алгоритм для поиска клеточных автоматов}
Для получения приближенных результатов, воспользуемся генетическим алгоритмом~\cite{genetic-algo}. 
\textbf{Особи} "--- сетки с клеточными автоматами, \textbf{гены} "--- правила перехода для клеточных автоматов,
\textbf{приспособленность} особи "--- суммарная по двумерной сетке степень совпадения каждой окрестности ячейки клеточного автомата некоторому целевому изображению (паттерну), 
воспроизведение которого и будет являться целью каждого эксперимента. 


\subsection{Подсчет приспособленности}
Для правильной работы генетического алгоритма, нам нужно различать <<полезные>> особи от <<ненужных>>. Для этого определим приспособленность особи.
Приспособленностью особи будем считать процент совпадения окрестностей клеток на сетке заданному перед началом эксперимента паттерну. 

При подсчете приспособленности учитывается количество допустимых ошибок при сравнении с паттерном. Если число пикселей, не совпадающих с целевым изображением, превышает порог, мгновенно переходим на следующую итерацию. В противном случае, если X "--- максимальное количество допустимых ошибок, а Y "--- число несовпадений в паттерне, тогда к ответу прибавим 
$(1 + X - Y)/(X + 1)$.
Добавляя такой параметр, мы намеренно рискуем получить искаженный результат, не совпадающий полностью с паттерном, но зачастую такая мера необходима для значительного уменьшения времени сходимости к приемлемому результату. Однако выбранная нами формула стимулирует автомат находить результат без ошибок, что частично компенсирует недостаток, связанный с возможностью получения искаженного результата.

Также необходимо учесть, что мы можем искать совпадение не с единственным изображением, а с целым набором, как показано на изображении~\ref{ptn-cubes}. В таком случае, на каждой итерации, при проверке совпадения окрестности с паттерном, обрабатывая каждую ячейку, к аккумулятору приспособленности добавляется максимальное значение приспособленности по всем паттернам.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/Patterns-many-cube}
	\caption{Пример случая, когда проверяется совпадение с несколькими паттернами}\label{ptn-cubes}
\end{figure}

Полный код функции приведен в приложении~\ref{fitness-calc-normal}.

В идеальном случае, нам хотелось бы высчитать некоторую нормализованную функцию приспособленности, которая бы для сетки любой размерности и любого набора паттернов давала бы значение в диапазоне от 0 до 1 (или 100, для наглядности). Подобная функция учитывала бы максимально возможное количество изображений на паттерне. Таким образом мы могли бы поделить количество вхождений паттерна в изображении на максимально возможное и измерить процент совпадения. В реальности же это достижимо только с помощью полного перебора всей сетки, что в самом простом случае, без оптимизаций, при размере изображения $64\times64$, требовало бы произвести $2^{64\times64}$ подсчетов приспособленности. Поэтому для упрощения, будем считать значение приспособленности равным 100 если изображение полностью состоит из паттернов без пересечения. Например, если исходное изображение имеет размерность $64\times64$, а паттерн "--- $4\times4$, то на изображении возможно разместить $(64\times64) / (4\times4) = 256$ копий паттерна. В таком случае приспособленность будет равна 100.

Подведем подсчет приспособленности на последних итерациях и сделаем возможным устанавливать количество итераций перед процессом эволюции. Между двумя подсчетами приспособленности происходит ровно одно обновление клеточных автоматов на сетке.

Если запустить программу с профилировщиком, можно заметить, что самым затратным по времени местом в программе является именно подсчет приспособленности (см. рис.~\ref{fitness-calc-bad}). Это не удивительно, ведь для каждого пикселя сетки приходится проверять соответствие окрестности заданному паттерну, а с увеличением его размера в X раз, в столько же раз увеличивается и количество операций доступа при подсчете приспособленности. Далее попробуем оптимизировать этот процесс.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{images/Profiler-bad}
	\caption{Фрагмент окна профилировщика. Видимые подъемы связаны с процессом подсчета приспособленности}\label{fitness-calc-bad}
\end{figure}

\subsection{Подсчет приспособленности на основе данных с GPU}
Попробуем снизить нагрузку во время подсчета приспособленности клеточных автоматов на сетке за счет переноса обновления сетки с процессора на видеокарту. Так как визуализация клеточных автоматов с помощью шейдеров уже готова, достаточно считывать изображение перед каждым подсчетом приспособленности.

После считывания, переведем пиксели цвета изображения в числа 0 и 1 и воспользуемся готовой функцией подсчета приспособленности.
\begin{minted}[fontsize=\footnotesize]{csharp}
	private float CalculateFitness(Texture2D texture2D, Pattern[] patterns)
	{
	  texturePixels = texture2D.GetPixels32();
	  return CalculateFitness(texturePixels, texture2D.width, texture2D.height, patterns);
	}
	
	byte[] texturePix = null;
	private float CalculateFitness(Color32[] texturePixels, int texW, 
		int texH, Pattern[] patterns)
	{
	  var texSize = texW * texH;
	  texturePix = new byte[texSize];
	  for (int i = 0; i < texSize; i++)
	  {
	      texturePix[i] = texturePixels[i].a;
	  }
	  return CalculateFitness(texturePix, texW, texH, patterns);
	}
\end{minted}

Вопреки ожиданиям, это не ускорило программу. Это можно объяснить тем, что скорость передачи данных с видеопамяти в оперативную память крайне медленная~\cite{gpu2cpu}.

\subsection{Оптимизация подсчета приспособленности}
Воспользуемся оптимизацией, описанной в разделе~\ref{signal-optimized}, с отличием в том, что паттерн может быть произвольного размера. Для начала переведем двоичные числа, образованные последовательным считыванием слева направа каждой строки паттерна и переводом в десятичное число и сохраним эту информацию во вспомогательном массиве. Данные числа останутся неизменными. Далее, проведем сравнение битов сетки клеточного автомата и паттерна.

Повторим действия, описанные в разделе~\ref{signal-optimized} для сетки клеточного автомата. Аналогично, переведем двоичные числа, образованные битами, в десятичные и запишем в массив. Таким образом, размерность массива по обоим измерениям будет совпадать с полученным для паттерна. 

Имея два двоичных числа в десятичном представлении, мы можем получить новое двоичное число, которое будет состоять исключительно из различающихся битов в двух исходных числах. Делается это с помощью операции XOR (сложение по модулю 2). В языке программирования \verb|C#| она обозначается как \verb|^|. 

В результате, мы получаем новое десятичное число, количество единиц в двоичном представлении которого равно количеству битов в окрестности ячейки, \textbf{не} совпадающих с паттерном. Для быстрого подсчета единиц, воспользуемся параллельным SWAR-алгоритмом, подробную информацию про который можно посмотреть в источнике~\cite{bithacks}.

После подсчета разницы, для каждого числа-буфера, полученного для сетки, используем побитовый сдвиг влево с выбрасыванием крайнего левого бита (используя бинарное <<И>>) и добавим новое число справа. Повторим алгоритм, пока не дойдем до конца сетки.

Далее вставлен основной фрагмент описанного кода. Полный код доступен в приложении~\ref{fitness-calc-optimised}.

\begin{minted}[fontsize=\footnotesize]{csharp}
for (short j = 0; j < textureWidth; j++)
 {
   cornerPixel = j + i * textureWidth;
   for (byte p = 0; p < patterns.Length; p++)
   {
       curErr[p] = 0;
   }
   int minErrors = patternErrors + 1;
   
   for (byte k = 0; k < patternHeight; k++)
   {
     int ind = (qOffset + k) % patternHeight;
     screenLine = screenLines[ind];
     newErr = patternLines[p][k] ^ screenLine;

     for (byte p = 0; p < patterns.Length; p++)
     {
       newErr = newErr - ((newErr >> 1) & 0x55555555);
       newErr = (newErr & 0x33333333) + ((newErr >> 2) & 0x33333333);
       curErr[p] += (((newErr + (newErr >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
     }

     screenLine <<= 1;
     if (screenLine >= patternCycle) screenLine -= patternCycle;
     nextPixInd = (((i + k) % textureHeight) * textureWidth) 
     	+ (j + patternWidth) % textureWidth;
     screenLine += texturePixels[nextPixInd];
     
     screenLines[(qOffset + k) % patternHeight] = (screenLine);
   }
   
   for (byte p = 0; p < patterns.Length; p++)
   {
       if (curErr[p] < minErrors) minErrors = curErr[p];
   }
   fitness += minErrors <= patternErrors ? 
    (1 + patternErrors - minErrors) * 1f / (patternErrors + 1) : 0;
}
\end{minted}

Даже с учетом подобных и ранее описанных оптимизаций в разделе~\ref{signal-optimized}, данный этап остается самым высоко нагруженным. Поэтому для пользователя программы сделана возможность определить количество подсчетов приспособленности на каждом цикле эволюции перед этапом скрещивания.

\subsection{Эволюция}\label{evolution}
Этап эволюции начинается после завершения подсчетов приспособленности клеточных автоматов на последних кадрах. На основании полученных данных будет отбираться половина особей с наивысшей приспособленностью, из них случайным образом будут созданы пары, каждая из которых создаст два потомка. Правила переходов для потомков формируются из генов родителей, которые также сохраняются до следующего этапа эволюции. В работе будут рассмотрены два вида скрещивания.

Для первого вида скрещивания выберем случайный номер бита в генах (правила перехода длиной 512), будем называть его <<разделителем>>. Все биты первого родителя до разделителя станут основой для правила перехода первого дочернего клеточного автомата, все биты с номером $\geq$ разделитель возьмутся из второго родителя. Для второго дочернего клеточного автомата, до разделителя берутся биты из второго родителя, а после "--- из первого.
% вставить картинку

Второй вид скрещивания реализован с помощью случайного выбора родителя для \textbf{каждого} бита.
% вставить картинку

После скрещивания случайным образом мутируем гены автоматов, полученных после этапа эволюции. В случае клеточных автоматов с возможными состояниями 0 и 1, 0 меняется на 1 и наоборот. Разрешим до X мутаций, а вероятность того что выбранный клеточный автомат мутирует "--- Y. Оба параметра настраиваются пользователем перед экспериментом.

\subsection{Сбор данных и визуализация эксперимента}
Перед началом эксперимента по поиску клеточного автомата, воспроизводящего паттерн, случайным образом создадим идентификационный номер (ID) эксперимента. Название сопутствующих файлов со статистикой будет содержать в суффиксе ID эксперимента. Во время исполнения эксперимента, можно наблюдать за графиком приспособленности (рис.~\ref{fitness-history}) и генофондом популяции (рис.~\ref{genofond-simple}-\ref{genofond-simple-end}).

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{images/fitness-history}
	\caption{Динамически построенный график приспособленности на эксперименте. Подробные числовые значения доступны в файлах с префиксом <<FH->>.}\label{fitness-history}
\end{figure}
% генофонд и график приспособленности

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.45]{images/geno-start}
	\caption{Генофонд популяции на старте. По оси X "--- биты генов от 0 до 512, по оси Y "--- клеточные автоматы в популяции (256)}\label{genofond-simple}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{images/geno-end}
	\caption{Генофонд популяции в автомате с высокой приспособленностью. Можно заметить, что некоторые биты гена остаются неизменными у всех особей}\label{genofond-simple-end}
\end{figure}

После каждого эксперимента статистика записывается в файлы. Она содержит полную информацию о настройках и результатах (средняя приспособленность, время, количество итераций эволюции) эксперимента, максимальные и средние значения приспособленности на каждой итерации, опорные биты (см. раздел \ref{pivot-bits}). Данные файлы расположены в папке:

\verb|{Расположение_проекта}/Assets/SimulationData/|

После завершения эксперимента, в файл также записываются и правила переходов в виде генов. Файл расположенный в пути:

\verb|{Расположение_проекта}/Assets/SimulationData/Genes/| 

Каждый файл имеет название \verb|G-{Имя_Паттерна}-{IDэксперимента}.txt|. 

В нем ген каждого клеточного автомата записывается в новой строке, и, соответственно, количество строк в файле определяется числом клеточных автоматов в проведенном эксперименте.

Для просмотра клеточных автоматов после эксперимента создана дополнительная сцена в Unity с названием \foreignlanguage{English}{GeneVisualisation}. В основном, она отличается от главной сцены тем, что в ней имеется одна большая сетка размерности $1024\times1024$ и отключена возможность эволюции автоматов. Для считывания файла с генами создан дополнительный скрипт. В редакторе необходимо выбрать автоматически созданный файл с данными генов. Запустив сцену, можно увидеть, как сетка меняет свое изначальное изображение~\ref{GeneVisualisation}, используя правила перехода из файла. Для переключения между всеми правилами в наборе, необходимо нажать стрелку влево или стрелку вправо на клавиатуре.

Нажатием клавиши <<P>> можно приостановить обновление клеточного автомата, повторное нажатие возобновляет его работу.

Нажатием клавиши <<R>> можно обновить состояние ячеек клеточного автомата в изначальное, то есть, значение каждой ячейки будет случайным.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{images/GeneVisualisation}
	\caption{Сцена для визуализации клеточных автоматов после эксперимента. Данный результат получен при попытке воссоздать паттерн <<квадрат $3\times3$ с рамкой в 1 пиксель противоположного цвета>>.}\label{GeneVisualisation}
\end{figure}


\section{Эксперименты}
Данный раздел будет посвящен проведению экспериментов для сбора статистики, с помощью которой в дальнейшем можно выявить зависимость между параметрами эксперимента и скоростью нахождения клеточных автоматов, удовлетворяющих заданным условиям

Перед выполнением экспериментов были поставлены следующие вопросы. Возможно ли найти такие параметры модели, которые для любого паттерна будут приводить к более быстрому нахождению клеточного автомата, моделирующего его? 

\subsection{Проведение эксперимента}
Перед проведением эксперимента необходимо определить его конфигурацию: количество клеточных автоматов, параметры генетического алгоритма и предельное значение количества итераций или приспособленности, при котором эксперимент будет завершен. Также должен быть указан файл, содержащий целевые изображения, которые клеточный автомат попытается воспроизвести. 

\subsubsection{Конфигурация параметров эксперимента}\label{configuration}
Перед началом эксперимента в окне редактора (см. рис.~\verb|Unity|~\ref{sim-settings}) можно определить следующие значения параметров эксперимента:
\begin{itemize}
\item \verb|Update Period| "--- минимальное время между кадрами перед следующим обновлением автомата;
\item \verb|Screen Size In Pixels| "--- размер квадратной сетки (в количестве ячеек) по одному измерению;
\item \verb|Virtual Screens In Simulation| "--- (кратное 4) количество клеточных автоматов в эксперименте;
\item \verb|Screens In Simulation| "--- количество автоматов, для которых будет создана визуализация;
\item \verb|Time To Evolution| "--- время до первого подсчета приспособленности автоматов;
\item \verb|Mutation Percent| "--- вероятность, определенная для каждого автомата, того, что он мутирует;
\item \verb|Mutate Bits Up To| "--- X, количество битов, которые могут мутировать: от 1 до X;
\item \verb|Pivot Bit Fitness Threshold| "--- пороговое значение приспособленности, начиная с которого будут отслеживаться опорные биты (подробнее в разделе~\ref{pivot-bits});
\item \verb|Write To Global Pivot Bits| "--- записывать ли опорные биты в данном эксперименте в файл (подробнее в разделе~\ref{pivot-bits});
\item \verb|Fitness Calculations Needed| "--- количество подсчетов приспособленности перед этапом эволюции;
\item \verb|MS Fitness Threshold| "--- пороговое значение приспособленности для завершения эксперимента и перехода к следующему;
\item \verb|MS Calculations After Threshold| "--- дополнительное количество этапов эволюции после достижения порога (проверка, может ли клеточный автомат развиваться дальше, даже после достижения указанного порога);
\item \verb|Evolution Step Limit| "--- пороговое значение количества этапов эволюции для завершения эксперимента и перехода к следующему;
\item \verb|Cross Separation| "--- проводить ли скрещивание на основе разделителя (подробнее в разделе~\ref{evolution}).
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.85]{images/sim-settings}
	\caption{Конфигурация эксперимента.}\label{sim-settings}
\end{figure}

\subsubsection{Создание файла с паттернами}
Файлы с паттерном определяют целевое изображение, воспроизведение которого клеточным автоматом будет выполнено после применения генетического алгоритма. В первой строке указывается ширина и высота целевого изображения в пикселях. Третьим числом идет количество допустимых несовпадений в окрестности, при которых по-прежнему будет считаться, что паттерн нашелся.

Следующая строка может содержать любые символы, она оставлена на случай необходимости дополнительных конфигураций генетического алгоритма.

Затем необходимо указать количество паттернов и, используя 0 и 1, построчно записать пиксели паттерна. 0 "--- черный цвет, 1 "--- белый. Пример заполнения файла и соответствующее представление целевого изображения показано на рисунке~\ref{pattern-file}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{images/pattern-file}
	\includegraphics[scale=0.325]{images/patterns-many-cube}
	\caption{Создание файла с информацией о паттерне. На втором изображении показаны описанные в файле целевые изображения.}\label{pattern-file}
\end{figure}

\subsubsection{Запуск программы}
Перед запуском экспериментов необходимо удостовериться, что путь, указанный в настройках эксперимента, соответствует реальному в файловой системе. Для начала экспериментов необходимо либо нажать кнопку запуска внутри среды разработки \verb|Unity|, либо собрать приложение, перейдя во вкладку \verb|File->Build Settings|.

Приложение будет работать до тех пор, пока не будет отключено. В файл с результатами будет последовательно записываться информация о каждом проведенном эксперименте.

\subsubsection{Результаты эксперимента}
После каждого эксперимента остается блок сообщений~\ref{experiment-output}. Далее следует описание основных строк блока:

\begin{enumerate}
\item номер эксперимента и время проведения;
\item \verb|OK| "--- эксперимент завершился успешно, \verb|ABORT| "--- эксперимент прерван, что может произойти если его выполнение остановлено вручную или достигнуто предельное количество шагов эволюции, и дополнительно указывается прошедшее количество этапов эволюции с начала эксперимента (каждый этап: обновление автоматов, подсчет приспособленности, скрещивание);
\item количество времени в секундах, потраченного на эксперимент и итоговая средняя приспособленность по всем клеточным автоматам;
\item в последующих строках следует информация о конфигурации эксперимента, подробнее в разделе~\ref{configuration}.
\end{enumerate}

\begin{figure}[h]
	\begin{verbatim}
	Simulation [9185,813] -- 09.06.2020 10:28:01
	ABORT|Simulation aborted for PtnFive755 after 1001 evolutions.
	Time spent: 4583,473. Average good fitness: 0.
	Virtual screens: 128. Update period: 0,001. Time to evolution: 1,5.
	Fitness calculations between evolution: 25.
	Fitness threshold: 25. Additional steps after threshold: 100.
	Simple cross separation: False.
	Mutation percent: 25. Mutate up to 8 bits.
	
	
	Simulation [7321,073] -- 09.06.2020 11:30:24
	OK|Simulation finished for PtnFive755 after 966 evolutions.
	Time spent: 4074,686. Average good fitness: 25,2676.
	Virtual screens: 128. Update period: 0,001. Time to evolution: 1,5.
	Fitness calculations between evolution: 25.
	Fitness threshold: 25. Additional steps after threshold: 100.
	Simple cross separation: False.
	Mutation percent: 8. Mutate up to 8 bits.
	\end{verbatim}
	\caption{Вывод в результате двух экспериментов: первый закончился неудачно после 1000 шагов эволюции, второй завершился успешно с приспособленностью 25,2676 после 966 шагов эволюции. В первом эксперименте вероятность мутации каждого гена 0.25, во втором "--- 0.08 (последняя строка в сообщении).}\label{experiment-output}
\end{figure}


Информация по каждому проведенному эксперименту содержатся в репозитории на \verb|Github| в папке \verb|Statistics| по ссылке:

\url{https://github.com/Alexflames/diploma-cellular-automata}

\subsection{Поиск закономерностей в таблице переходов}\label{pivot-bits}
Предположим, что для любого правила клеточного автомата существуют биты, являющиеся наиболее важными при формировании определенного паттерна. Далее, для удобства, будем называть эти биты <<опорными>>. Тогда, для их нахождения создадим дополнительный массив, в котором будем хранить <<ценность>> бита. Определим её следующим образом:
\begin{enumerate}
\item К значению ценности бита прибавим 1, если бит гена равен единице, и $-1$ в противном случае.
\item Если приспособленность автомата меньше средней, то взять результат из п.1 и домножить на $-1$.
\item Итоговая ценность бита берется как значение по модулю от ценности бита.
\end{enumerate}
Будем считать \textbf{опорными} те биты, значение ценности по модулю которых превосходит среднее значение (по модулю) ценности среди всех битов правила.

Введенный нами алгоритм объясняется предположением, что в правиле найдутся биты, которые будут присутствовать только в автоматах с высокой приспособленностью. Добавим дополнительное ограничение на то, что подсчет опорных битов будет вестись лишь начиная с заданного процента приспособленности. Для наглядности будем отображать опорные биты на генофонде клеточных автоматов отдельным (оранжевым) цветом, как на изображении~\ref{genofond-pivot}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{images/genofond-pivot}
	\caption{Генофонд автоматов. Оранжевым цветом отображаются опорные биты.}\label{genofond-pivot}
\end{figure}

Однако, само по себе нахождение опорных битов в одном эксперименте не позволит сделать выводы о закономерностях в правилах. Для того чтобы узнать, сохраняются ли опорные биты для повторных попыток найти правила, воспроизводящих заданный паттерн, необходимо найти <<глобальные опорные биты>>. После каждого эксперимента запишем все опорные биты в новую строку в файл. Перед началом следующего эксперимента считаем строки с опорными битами и прибавим $+1$ к каждому глобальному значению ценности бита. Все биты, глобальное значение ценности которых превышает половину числа строк опорных битов, будут считаться глобальными опорными битами. Отобразим их на генофонде отдельным (бирюзовым) цветом, как на изображении~\ref{genofond-global-pivot}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{images/genofond-global-pivot}
	\caption{Генофонд автоматов. Бирюзовым цветом отображаются глобальные опорные биты.}\label{genofond-global-pivot}
\end{figure}

Полученные результаты противоречат предположению. С каждым последующим экспериментом количество глобальных опорных битов стремится к 0. С одной стороны, это можно объяснить тем, что существует множество изображений, удовлетворяющих цели эксперимента. Более того, для каждого целевого изображения существует множество клеточных автоматов, воспроизводящих его. Созданные клеточные автоматы могут быть периодичными и статичными.

Например, при попытке воспроизвести квадрат $3\times3$, клеточные автоматы могут создавать множество разнообразных фигур. Внешне это может выглядеть как если бы квадраты двигались в одну из 8 сторон или как одни квадраты появляются на месте других. Учитывая, что во многих паттернах мы для снижения времени экспериментов позволяем допускать ошибки, то полученные изображения будут выглядеть как исходные, и при этом иметь незначительные различия. Однако, эти различия играют важную роль в правилах клеточных автоматов. Некоторые клеточные автоматы для паттерна <<квадрат $3\times3$>> изображены на рисунке~\ref{different-squares}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/squares_vis2053}
	\includegraphics[scale=0.5]{images/squares_vis2063}
	
	\vspace{0.25em}
	
	\includegraphics[scale=0.5]{images/squares_vis2100}
	\includegraphics[scale=0.5]{images/squares_vis4424}
	\caption{Некоторые клеточные автоматы, полученные для одного паттерна.}\label{different-squares}
\end{figure}

Более того, если рассмотреть гены клеточных автоматов из разных экспериментов (№1935 и №2021), но дающих почти неразличимые внешне результаты, как изображено на рис.~\ref{similar-squares}, то будет понятно, что и гены, и опорные биты в этих автоматах тоже не будут совпадать. Из этого можно сделать вывод о том, что данным методом невозможно ни экспериментально, ни аналитически определить диапазон поиска клеточных автоматов.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/squares_vis1935}
	\includegraphics[scale=0.5]{images/squares_vis2021}
	\caption{Внешне схожие клеточные автоматы с разных экспериментов.}\label{similar-squares}
\end{figure}

Все дальнейшие оптимизации нахождения паттерна будут проводиться за счет выбора <<правильной>> конфигурации эксперимента, чему и посвящены следующие разделы.

\subsection{Описание проведенных экспериментов}\label{description}
В настоящей работе было проведено 1306 экспериментов над различными паттернами. Каждый паттерн дополняется похожими версиями себя, которые строятся отражением по вертикали или горизонтали исходного целевого изображения или сменой цветов на противоположные (черный на белый и наоборот).

Далее следует описание количества экспериментов, проведенных для некоторых целевых изображений. Визуальное представление паттернов изображено на рисунке~\ref{patterns}.

\begin{itemize}
\item 222 над <<крестом $5\times5$ с одной ошибкой>>;
\item 43 над <<елкой $5\times5$ с одной ошибкой>>;
\item 346 над <<елкой $5\times5$ с двумя ошибками>>;
\item 215 над <<квадратом $3\times3$ и рамкой 1 пиксель противоположного цвета с двумя ошибками>>;
\item 22 над <<повернутой в 4 стороны елкой $5\times5$ с одной ошибкой>>;
\item 70 над <<цифрой '5' в рамке, $7\times5$ с пятью ошибками>>;
\item 84 над <<треугольник $7\times5$ в двух поворотах с шестью ошибками>>.
\end{itemize}

\begin{figure}[h]
	\centering
	
	\includegraphics[scale=0.19]{images/pattern-cross}
	
	\includegraphics[scale=0.2]{images/pattern-elka}
	
	\includegraphics[scale=0.2]{images/Patterns-many-cube}
	
	\includegraphics[scale=0.2]{images/Pattern-elka-sym}
	
	\includegraphics[scale=0.2]{images/pattern-five}
	
	\includegraphics[scale=0.25]{images/triangle-4}
	
	\caption{Паттерны: <<крест $5\times5$>>, <<елка $5\times5$>>, <<квадрат $3\times3$ и рамка 1 пиксель противоположного цвета>>, 
	<<крест $5\times5$ и рамка 1 пиксель противоположного цвета>>, <<повернутая в 4 стороны елка $5\times5$>>, <<цифра '5' размера $5\times5$>>, 
	<<треугольник $7\times5$ в двух поворотах>>.}\label{patterns}
\end{figure}

Можно заметить, что большая часть паттернов имеет размер $5\times5$. Такой выбор объясняется тем, что клеточные автоматы для паттернов такого размера зачастую ищутся примерно за 300 этапов эволюции, что позволяет провести значительное количество экспериментов за относительно короткий промежуток времени и одновременно заметить разницу между различными параметрами генетического алгоритма. Так как в дальнейшем выводы о наилучшей конфигурации будут браться из статистических данных, необходимо провести большое количество запусков программы.

\section{Анализ экспериментов}
Данный раздел посвящен анализу данных, полученных после проведения экспериментов. Для каждого целевого изображения проводились эксперименты с различными настройками генетического алгоритма: количество клеточных автоматов, вероятность мутации, число мутирующих битов. Основываясь на полученных результатах можно сделать вывод о наилучших параметрах генетического алгоритма, при которых происходит более быстрое воспроизведение целевого изображения.

\subsection{Обработка и визуализация данных}
Для обработки и визуализации полученных данных создана программа, написанная на языке \verb|Python| с использованием библиотеки \verb|Matplotlib|. Программный код с комментариями написан в среде \verb|Jupyter Notebook|, позволяющей создать наглядный и задокументированный программный код с сохраненным результатом выполнения. Файл в формате \verb|.ipynb| хранится в репозитории. Он расположен в корне папки \verb|Statistics|.

Данный <<ноутбук>> собирает и обрабатывает все файлы со статистикой по выбранному набору файлов. Интерфейсом между данными и программистом выступает функция \verb|analyze|, которая принимает на вход список файлов и любое количество пар \verb|(функция,номер строки)|. К каждой выбранной строке в блоке вывода по эксперименту будет применена заданная функция.
\begin{minted}{python}
def analyze(statistics_files, *funcs_indices):
    for file in statistics_files:
        f = open(file, 'r')
        cur_index = 0
        for line in f:
            for f_ind in funcs_indices:
                if (cur_index == f_ind[1]):
                    f_ind[0](line)
            cur_index += 1
            cur_index = cur_index % 10
        f.close()
\end{minted} 

В качестве примера приведем функцию, которая совершит подсчет времени, затраченного на эксперименты. Для этого подготовлены две вспомогательные функции. Первая, по входной строке определяет, для какого паттерна проведен эксперимент. Вторая функция получает затраченное на него время в секундах и добавляет к соответствующему аккумулятору (в словарь, ключом к которому является название паттерна). Вызовем функцию \verb|analyze|, передав в параметры список файлов с данными по экспериментам и вспомогательные функции вместе с номерами строк. Полученный фрагмент кода выглядит следующим образом:

\begin{minted}{python}
def calculate_time(statistics_files, patterns):
    time_accum = dict()
    for pattern in patterns:
        time_accum[pattern.split('Stats-')[1].split('.txt')[0]] = 0

    current_pattern = ""
    
    def get_current_pattern(line):
        nonlocal current_pattern
        current_pattern = line.split('for')[1]
        	.split('after')[0].strip()
        
    def success_time(line):
        nonlocal time_accum
        time_acc = int(line.split('.')[0].split(':')[1]
        	.split(',')[0])
        if (time_acc > 0):
            time_accum[current_pattern] += int(line.split('.')[0]
            	.split(':')[1].split(',')[0])
    
    analyze(statistics_files, 
    	(get_current_pattern, 1), (success_time, 2))
    
    for entry in time_accum.keys():
        time_accum[entry] /= 3600
        
    return time_accum
\end{minted}

Наконец, сделаем визуализацию полученных результатов в графиках~\ref{hours}. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/hours}
	\caption{Визуализация времени работы. По оси X "--- названия паттернов, по Y "--- время в часах.}\label{hours}
\end{figure}

Аналогичным образом посмотрим на количество проведенных экспериментов~\ref{exp-count}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/exp-count}
	\caption{Визуализация количества проведенных экспериментов. По оси X "--- названия паттернов, по Y "--- количество.}\label{exp-count}
\end{figure}

\subsection{Паттерн-зависимые результаты эксперимента}
Прежде чем начать сравнивать различные конфигурации генетического алгоритма, необходимо понять, как отличаются попытки найти различные целевые изображения. Основное внимание будет уделяться следующим характеристикам паттернов: размерность (первые 2 числа в названии), количество допустимых ошибок (последнее число в названии), симметричность. Посмотрим на среднее время выполнения экспериментов~\ref{average_time}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/pattern_average_time}
	\caption{Визуализация среднего количества времени на 1 эксперимент для некоторых паттернов. По оси X "--- названия паттернов, по Y "--- время в часах.}\label{average_time}
\end{figure}

Не удивительно, что чем больше ошибок допускается при сравнении с целевыми изображениями, тем больше диапазон возможных клеточных автоматов, воспроизводящих заданные паттерны. Тем самым, время поиска любой подходящей комбинации битов в генах снижается. В случае с паттерном <<елка $5\times5$>> разница между средним временем работы в случае двух и одной ошибки "--- 3.5 раза.

Интересными оказались наблюдения, связанные с паттернами одинакового размера. Можно заметить, что среднее время работы паттерна <<крест $5\times5$>> и <<елка $5\times5$>> сильно различаются. Более того, в первом допускается всего 1 ошибка, и даже с учетом этого он ищется примерно в два раза быстрее чем <<елка $5\times5$>> с двумя допустимыми ошибками. На основании полученных данных по всем экспериментам можно сделать предположение, что на скорость нахождения определенного паттерна влияет форма изображения. Паттерны, внешне похожие на линии и простые фигуры, ищутся быстрее чем сложные изображения.

В связи с высокой долей непредсказуемости результатов по разным паттернам, будем сравнивать друг с другом лишь эксперименты, проведенные над одинаковыми целевыми изображениями. Для минимизации вероятности того, что с определенным паттерном <<повезло>>, проведем эксперименты с разными параметрами генетического алгоритма над несколькими целевыми изображениями.

\subsection{Оптимальные параметры эксперимента}
Важной составляющей для достижения наиболее быстрого нахождения клеточного автомата, воспроизводящего заданные целевые изображения, является подбор параметров для генетического алгоритма. В настоящей работе рассматриваются следующие основные параметры генетического алгоритма: процент мутации и максимальное количество бит, которые могут быть мутированы (выбирается случайное число от 1 до максимального).

Для проведения экспериментов были выбраны паттерны, приближенный результат для которых находится меньше чем за 500 итераций (полчаса реального времени). Это позволит провести большое количество экспериментов, тем самым проверив множество комбинаций процента мутации и количества бит. Полученные результаты для трех целевых изображений: <<квадрат $3\times3$ с рамкой 1 пиксель>>, <<елка $5\times5$>>, <<крест $5\times5$>> и <<треугольник $7\times5$ в двух поворотах>>~\ref{description}.

Полученные результаты отражены на изображениях~\ref{square552},~\ref{elka552},~\ref{cross551},~\ref{triangle576}. Данные эксперименты проводились для различных комбинаций процента мутаций и количества бит в мутации. Из файла с результатами эксперимента (в первом ряду на изображениях) извлечена информации по среднему коэффициенту приспособленности, что является главным критерием соответствия целевому изображению. Также выведем количество проведенных экспериментов, чтобы убедиться, что для всех конфигураций проведено достаточно экспериментов. Во втором ряду изображений расположен график процента успешных/неудачных экспериментов при установленном пороговом значении 25 и среднее количество этапов эволюции от начала до конца эксперимента. Для всех экспериментов в данном разделе выбиралось пороговое значение приспособленности равное 25, а количества экспериментов "--- 500. Таким образом, эксперимент может закончиться раньше, если пороговое значение было достигнуто.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{images/square552}
	\caption{Результаты экспериментов для паттерна <<квадрат $3\times3$ с рамкой 1 пиксель противоположного цвета>> с 2 допустимыми ошибками. По оси X "--- конфигурация генетического алгоритма в виде пары чисел через запятую: вероятность мутации в процентах и максимальное количество бит для мутации. }\label{square552}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{images/elka552}
	\caption{Результаты экспериментов для паттерна <<елка $5\times5$>> с 2 допустимыми ошибками. По оси X "--- конфигурация генетического алгоритма в виде пары чисел через запятую: вероятность мутации в процентах и максимальное количество бит для мутации. }\label{elka552}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{images/cross551}
	\caption{Результаты экспериментов для паттерна <<крест $5\times5$>> с 1 допустимой ошибкой. По оси X "--- конфигурация генетического алгоритма в виде пары чисел через запятую: вероятность мутации в процентах и максимальное количество бит для мутации. }\label{cross551}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{images/triangle576}
	\caption{Результаты экспериментов для паттерна <<треугольник $7\times5$ в двух поворотах>> с 6 допустимыми ошибками. По оси X "--- конфигурация генетического алгоритма в виде пары чисел через запятую: вероятность мутации в процентах и максимальное количество бит для мутации. }\label{triangle576}
\end{figure}

По результатам эксперимента можно сделать выводы о параметрах генетического алгоритма, дающих большую приспособленность. Вполне ожидаемо, что низкий процент мутации и мутация одного бита не дает достаточного разнообразия особей. Рассматривая высокие вероятности мутации и количество бит, можно заметить, что конфигурация генетического алгоритма, при которой процент мутации равен 25, а количество бит может достигать 8 или 16, дает наилучшую приспособленность среди всех других рассмотренных конфигураций генетических алгоритмов. Дальнейшее увеличение процента мутаций и количества бит не даст увеличения коэффициента приспособленности, потому что дочерние особи будут слишком сильно отличаться от родительских. Снижение процента мутации, наоборот, не создает достаточного разнообразия особей.

Данные закономерности прослеживаются для различных паттернов: разной размерности, сложности фигуры, количества допустимых ошибок. Поэтому можно быть уверенным, что данные результаты применимы к любому паттерну, и скорее всего к некоторым другим способам подсчета приспособленности, так как выбор данных параметров генетического алгоритма контролирует только разнообразие популяции, отвечая за то чтобы производные автоматы, созданные в процессе скрещивания, были одновременно и похожими на родителей, и совмещали себе новые черты.

Результаты для некоторых других паттернов показаны на рисунках~\ref{elka551},~\ref{five755}.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{images/elka551}
	\caption{Результаты экспериментов для паттерна <<елка $5\times5$>> с 1 допустимой ошибкой. По оси X "--- конфигурация генетического алгоритма в виде пары чисел через запятую: вероятность мутации в процентах и максимальное количество бит для мутации. }\label{elka551}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{images/five755}
	\caption{Результаты экспериментов для паттерна <<цифра '5' размера $7\times5$>> с 5 допустимыми ошибками. По оси X "--- конфигурация генетического алгоритма в виде пары чисел через запятую: вероятность мутации в процентах и максимальное количество бит для мутации. }\label{five755}
\end{figure}

\subsection{Дальнейшие исследования}
В предыдущих разделах рассматривается повышение скорости нахождения приближенного паттерна с помощью конфигурации генетического алгоритма, но есть две нерешенные проблемы.

\begin{enumerate}
\item Некоторые паттерны даже относительно небольших размеров ($5\times5$, например) требуют больших вычислительных ресурсов, чтобы их найти. Особенно сложными являются паттерны, в которых отсутствует симметричность или имеется сильный дисбаланс в распределении черных и белых ячеек (особенно если размер паттерна достаточно высокий).
\item Не все полученные клеточные автоматы воспроизводят изображение, внешне похожее на исходное.
\end{enumerate}

В качестве иллюстрации второй проблемы, возьмем паттерн <<цифра 'пять' размера $5\times5$>> (изображение~\ref{five-repres}). Если позволить клеточному автомату допускать две ошибки при сравнении с целевым изображением, то с высокой вероятностью найдется более простая фигура, представляющая собой параллельные линии. Данная закономерность была выявлена эмпирическим путем: паттерн, состоящий из параллельных линий, находится намного быстрее чем более сложные изображения. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/five-representation}
	\caption{Слева "--- паттерн <<цифра 'пять' размера $5\times5$>>. Возможная вариация с двумя ошибками показана изображением справа.}\label{five-repres}
\end{figure}

Далее изложены предположения о том, какие изменения алгоритма теоретически могли бы улучшить поиск клеточных автоматов. Подробные исследования на данную тему не проводились ввиду значительного увеличения объема работы и времени экспериментов.

\textbf{Альтернативное множество начальных состояний}. Если вместо случайного заполнения всех ячеек клеточного автомата заполнить лишь одну клетку (например, в центре сетке), то некоторые клеточные автоматы смогут производить более упорядоченные изображения на первых итерациях обновления клеточного автомата.

\textbf{Клеточные автоматы высшего порядка}. Клеточному автомату можно добавить память, другими словами, возможность запоминать свои состояния на предыдущих итерациях. Такие клеточные автоматы называются клеточными автоматами высшего порядка. При переходе ячеек в новые состояния учитываются значение в них на предыдущих итерациях. Добавление памяти увеличивает количество всех возможных клеточных автоматов и одновременно с этим усложняет поиск клеточного автомата, удовлетворяющего условию.

\textbf{Другое множество правил перехода}. В данной работе правила перехода строились как комбинация состояний ячеек в окрестности Мура порядка 2. Как минимум еще один возможный вариант: окрестность фон Неймана, как изображено на рисунке~\ref{neiman}. Таким образом, количество возможных правил перехода изменится, и вместе с этим и множество клеточных автоматов.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/neiman}
	\caption{Окрестность фон Неймана порядка 1 и 2 для некоторой ячейки (изображена зеленым цветом).}\label{neiman}
\end{figure}

\textbf{Измененные правила подсчета приспособленности}. Для особо сложных паттернов, для которых сложно заранее определить количество возможных ошибок, можно подсчитывать приспособленность как максимальное количество клеток по всей сетке, совпавших с целевым изображением. Также при сильном различии количества белых и черных клеток в целевом изображении, можно добавить дополнительное условие, чтобы разница между количеством клеток разных цветов не превышала определенного порога, и если порог превышен, то приспособленность считать равной 0. В таком случае есть риск, что критерий приспособленности будет слишком <<жестким>>, однако при этом исключается возможность получения в результате эксперимента неправильного паттерна.

\textbf{Защита от мутации особей с наивысшей приспособленностью}. В текущей реализации возможна ситуация, что особь с наивысшей приспособленностью после шага мутации будет изменена, что приведет к потере последовательности битов в гене, дающих хороший результат. С другой стороны, зачастую одна особь, дающая высокую приспособленность на каком-то шаге, не будет давать высокие показатели на последующих. Причина этого "--- случайная начальная заполненность ячеек клеточного автомата.

\textbf{Перебор случайных генов при низкой приспособленности}. Даже когда приспособленность особей близка к нулю, генетический алгоритм скрещивает биты генов, создавая новые гены. Возможно, будет более эффективным брать новые случайные гены вместо скрещивания.



\newpage
%===========================================
% Раздел "Заключение"
\conclusion
В результате дипломной работы было создано полноценное приложение для нахождения и визуализации двумерных клеточных автоматов первого порядка, воспроизводящих заданное целевое изображение. Данное приложение применимо для проведения экспериментов по подбору наилучших параметров для быстрого и эффективного (по значению приспособленности) поиска заданных клеточных автоматов. С помощью приложения были проведены эксперименты для различных параметров генетического алгоритма. На основе обработанных данных были определены оптимальные параметры генетического алгоритма. Оптимизации также проведены в коде программы, что привело к сокращению времени исполнения алгоритмов в несколько раз.  
Полученные результаты можно использовать и для других клеточных автоматов: высшего порядка, с большим числом состояний, с другим множеством начальных состояний.

%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением

\appendix

\section{Код оптимизированной функции переходов}\label{code-update-optimised}
\lstinputlisting{code/OptimisedUpdateCA.cs}
\section{Код функции подсчета приспособленности}\label{fitness-calc-normal}
\lstinputlisting{code/PatternFitness.cs}
\section{Оптимизированный подсчет паттерна}\label{fitness-calc-optimised}
\lstinputlisting{code/PatternFitnessOptimised.cs}
\section{Файловая структура проекта}\label{filesystem}
На приложенном диске можно ознакомиться со следующими файлами:

\textbf{Папка} \verb|Assets\Scripts| "--- код приложения, моделирующего клеточные автоматы;

\textbf{Папка} \verb|Assets\Scenes| "--- сцены для проекта в среде разработке \verb|Unity|;

\textbf{Файл} \verb|Statistics\Statistics.ipynb| "--- \verb|IPython Notebook| для анализа данных, полученных после эксперимента;

\textbf{Папка} \verb|Statistics\SimulationData| "--- данные, полученные в ходе экспериментов: результаты, гены и другие данные по каждому эксперименту.

Все остальные папки и файлы вспомогательные, нужны для корректной работы приложений.

\section{Статистика по экспериментам}\label{textstatistics}
\begin{table}[h]
	\centering
	\caption{Объединенные данные по экспериментам в текстовом формате}
	\small
	\begin{tabular}{|c|c|c|c|c|c|}
			\hline Название & Макс. ошибок & Процент & Макс. бит & Кол-во & Средняя прис- \\
			паттерна  & в паттерне & мутации & мутаций (до) & запусков & пособленность \\
			\hline Square55  & 2 & 5 & 4 & 23 & 25.1729 \\
						 <<Квадрат & ~ & 15 & 1 & 21 & 22.5189 \\
						 $3\times3$& ~ & 15 & 4 & 33 & 19.5767 \\
						 с рамкой	 & ~ & 15 & 8 & 81 & 32.0888 \\
						1 пиксель>>& ~ & 25 & 4 & 40 & 30.8100 \\
						 ~			   & ~ & 25 & 8 & 17 & 31.6848 \\
			\hline Elka55    & 2 & 5 & 4 & 27 & 66.4780 \\
						 <<Елка	   & ~ & 5 & 8 & 29 & 68.8953 \\
						 размера   & ~ & 8 & 8 & 58 & 64.1287 \\
					 $5\times5$>>& ~ & 15 & 1 & 18 & 63.0735 \\
						 ~			   & ~ & 15 & 8 & 63 & 82.0487 \\
						 ~			   & ~ & 25 & 2 & 26 & 82.1514 \\
						 ~			   & ~ & 25 & 4 & 32 & 91.6327 \\
						 ~			   & ~ & 25 & 8 & 44 & 80.5325 \\
						 ~			   & ~ & 25 & 16 & 50 & 98.2182 \\
			\hline ~			   & 1 & 5 & 1 & 15 & 5.9828 \\
						 ~			   & ~ & 15 & 1 & 8 & 16.9715 \\
						 ~			   & ~ & 25 & 4 & 20 & 30.2779 \\
			\hline Сross55   & 1 & 15 & 1 & 127 & 116.1352 \\
   <<Крест $5\times5$>>& ~ & 15 & 8 & 100 & 134.2668 \\
			\hline Triangle57& 6 & 15 & 8 & 28 & 3.0381 \\
	<<Треугольник 		   & ~ & 25 & 8 & 26 & 4.0253 \\
			$5\times7$>>	   & ~ & 25 & 16 & 30 & 4.5005 \\
			\hline Five75    & 5 & 8 & 8 & 18 & 2.8075 \\
			 <<Цифра '5'	   & ~ & 15 & 8 & 24 & 0.0001 \\
	размера $7\times5$>> & ~ & 25 & 8 & 28 & 5.8196 \\
			\hline
	\end{tabular}
	
\end{table}

\end{document}
