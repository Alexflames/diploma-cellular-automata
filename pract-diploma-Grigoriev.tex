\documentclass[bachelor, och, pract, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{longtable}
\usepackage{array}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[english,russian]{babel}

\usepackage[colorlinks=true]{hyperref}

\lstset{%
  language=[LaTeX]TeX,
  basicstyle=\small,
  tabsize = 2,
  breaklines=true,
  columns=fullflexible
}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Оптимизации поиска приближенных решений в эволюционирующих клеточных автоматах}

% Курс
\course{4}

% Группа
\group{451}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Григорьева Алексея Александровича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н., доцент} % степень, звание
\chname{А.\,С.\,Иванов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент} %должность, степень, звание
\saname{М.\,С.\,Семенов}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{доцент}
\paname{М.\,С.\,Семенов}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{8}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{преддипломная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{4}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{30.04.2020}
\practFinish{27.05.2020}

% Год выполнения отчета
\date{2020}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations
%\begin{description}
    %\item \foreignlanguage{english}{EVM} "--- %\foreignlanguage{english}{Ethereum Virtual Machine};
%\end{description}

% Раздел "Определения". Может отсутствовать в работе
%\definitions
%Паттерн "--- целевое изображение, воспроизведение которого должно быть достигнуто клеточным автоматом.

%Эксперимент (в контексте данной работы) "--- процесс поэтапной эволюции клеточных автоматов с целью достижения максимального совпадения воспроизводимых ими результатов заданным наперед паттернам.

%Сетка "--- двумерная регулярная решетка ячеек.


% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro
Клеточный автомат "--- дискретная модель, изучаемая теорией автоматов~\cite{automata}. В общем случае, клеточный автомат состоит из регулярной решетки ячеек, множества состояний, множества входных сигналов и функции перехода. Клеточные автоматы применяются в компьютерном зрении~\cite{edge-detection}, криптографии~\cite{crypto}, компьютерной графике\cite{cgraphics} и при моделировании различных процессов: физических~\cite{physics}, химических~\cite{chemistry}, биологических~\cite{bio}. Одним из наиболее известных является клеточный автомат "--- игра <<Жизнь>>~\cite{conways}.

Существует огромное количество конфигураций клеточных автоматов. Меняя число возможных состояний, правила подсчета входных сигналов, начальный сигнал, мы получаем новые множества автоматов, перебор которых невозможен с текущими мощностями. Поэтому, для поиска клеточных автоматов, удовлетворяющих каким-либо условиям, используют алгоритмы нахождения приближенного результата. В недавних работах на схожую тему применялись генетические алгоритмы~\cite{genetic-first} и нейронные сети~\cite{mordvintsev2020growing}.
В настоящей работе это осуществляется с использованием генетических алгоритмов. 

В основе работы лежит выполнение экспериментов по нахождению приближенного решения клеточными автоматами.
Цель каждого эксперимента "--- стабильное выполнение заданных условий изображениями, полученными после работы клеточных автоматов над изображением из множества начальных состояний. В данной работе начальное изображение задано случайно в каждом пикселе.
Для наглядности в качестве цели, которая будет поставлена перед началом экспериментов, будет воспроизведение заданного наперед целевого изображения (паттерна). Благодаря работе с изображениями можно будет не только полагаться на полученные числовые значения, но и сопоставить результат с визуализацией в приложении. После каждого эксперимента должна сохраняться исчерпывающая информация о поведении клеточного автомата. По ней должно быть возможно определить, был ли удачным эксперимент, сколько было затрачено времени, и какая была конфигурация эксперимента.

Эксперименты по оптимизации проводились для двумерных клеточных автоматов первого порядка, с возможными состояниями 0 и 1. Следующее состояние ячейки клеточного автомата определяется 9 соседними ячейками на решетке включая данную или, другими словами, окрестностью Мура порядка 2~\cite{moore}. 
Тип автоматов выбран не случайно: количество возможных правил, описывающих их, равно $2^{512}$~\cite{twodimensional},
что гарантирует невозможность перебора. %ссылка на переборы?, лол
Более того, не существует и общего аналитического решения для воспроизведения автоматами произвольного изображения, при условии что изначальная двумерная сетка задана случайными значениями.
У выбранных в данной работе типов клеточных автоматов также есть преимущества, связанные с возможностью оптимизации алгоритмов с использованием быстрых побитовых операций~\cite{bithacks-perf}. %слегка косяк ибо следующее предложение немного не связано с этим, но намекает собой на это
Многие из описанных далее результатов возможно перенести на случай клеточных автоматов \verb|N|-го порядка~\cite{higherorder}, % так ли это? Если да, нужно цитировать
а также для клеточных автоматов с увеличенным количеством состояний или иными правилами переходов.

Целью настоящей работы является создание полноценного приложения для проведения экспериментов по оптимизации поиска приближенного решения на основе паттернов двумерными клеточными автоматами первого порядка. Должно быть создано гибкое приложение с возможностью конфигурации алгоритма. Оптимизация должна быть проведена как за счет скорости исполнения, так и за счет настройки генетического алгоритма. Полученные результаты будут проанализированы в дипломной работе.

\section{Окружение для проведения экспериментов}
В данном разделе приведено описание проекта и вспомогательных функций для моделирования и визуализации двумерных клеточных автоматов первого порядка. 

\subsection{Среда разработки}
Поставленная задачу выполнена с использованием среды разработки \verb|Unity|. Такой выбор основан удобствами, предоставляемыми средой разработки. В частности, на выбор повлияли следующие её преимущества:
\begin{itemize}
\item быстрая и многофункциональная работа с графикой посредством готовых функций и визуального проектирования;
\item профессиональные инструменты для отладки и профилирования производительности программы;
\item наглядность результата программы.
\end{itemize}

Программный код написан на языке \verb|C#|. Основная логика экспериментов реализована в сцене \foreignlanguage{English}{MainScene}. Весь проект подключен к системе контроля версий %можно сослаться либо на систему контроля версий
Git~\cite{git} на базе популярного ресурса для хранения версий Github. Ссылка на <<репозиторий>>: \url{https://github.com/Alexflames/cellular-automation}. % либо на гитхаб


\subsection{Реализация клеточного автомата}
Каждый клеточный автомат представляется ячейками на двумерной сетке. %упомянуть периодичные граничные условия 
Ради прозрачности процесса и наглядности результатов, эксперимент проводится полностью в реальном времени: в каждую единицу времени все ячейки автоматов на всех сетках переходят в новое состояние, определенное входными сигналами и правилами перехода.

Опишем правила перехода для двумерного клеточного автомата первого порядка. При подсчете входного сигнала в ячейке автомата будут учитываться как и состояние данной ячейки, 
так и состояния восьми соседних ячеек в окрестности Мура порядка 2, для подсчета берутся значения с последней итерации. Возьмем самый простой случай: автомат может принимать значения 0 и 1. Таким образом, возможны $2^9=512$ вариантов входных сигналов. Отсюда и берется упомянутое ранее количество всевозможных правил для данных клеточных автоматов, $2^{512}$.

В качестве визуализации клеточных автоматов в \verb|Unity| можно использовать шейдеры. Плюс этого подхода заключается в том, что компьютер не будет тратить ресурсы оперативной памяти для визуализации автоматов, и вся нагрузка на это отдается видеокарте, находящейся большую часть времени в простое. Шейдеры позволяют создавать крупные визуализации огромной размерности благодаря эффективным вычислениям на видеокарте~\cite{gpu-performance}. 

\subsubsection{Правило перехода} \label{simple-update}
Создадим простейшую реализацию подсчета сигнала для таблицы перехода для каждого клеточного автомата. 
Для избежания лишних затрат памяти, в основной части программы заранее созданы массивы для временного хранения состояний автомата на следующем шаге. Также это необходимо, чтобы полученный результат не влиял на соседние автоматы в данный момент.

Создадим цикл, который будет выполняться на двумерной сетке клеточных автоматов размерностью \verb|screenSizeInPixels| по X и Y.
\begin{minted}[fontsize=\footnotesize]{csharp}
	var nextCAField = nextVirtualScreens[ind];
	var screen2DSize = screenSizeInPixels * screenSizeInPixels;
	for (short i = 0; i < screenSizeInPixels; i++)
	{
	   for (short j = 0; j < screenSizeInPixels; j++)
	   {
	       int signal = 0;
	       for (short k = 0; k < 3; k++)
	       {
	           for (short m = 0; m < 3; m++)
	           {
	               signal += CAField[
	                   (screen2DSize + screenSizeInPixels * i + j
	                   + screenSizeInPixels * (k - 1) + (m - 1)) 
	                   % (screen2DSize)] << (k * 3 + m);
	           }
	       }
	       nextCAField[i * screenSizeInPixels + j] = (byte)allRules[ind][signal];
	   }
	}
	
	for (short i = 0; i < screen2DSize; i++)
	{
	   CAField[i] = nextCAField[i];
	}
\end{minted}

\subsubsection{Оптимизированное вычисление входных сигналов} \label{signal-optimized}
Заметим, что в вычислении следующего состояния каждого автомата используется 9 обращений к сетке. Более того, при каждом последующем обращении к сетке после первого, повторно считываются 6 состояний. Представим квадрат $3\times3$, окрестность Мура порядка 2, в виде окна, которое можно сдвигать вправо по сетке. Разобьем окно на 3 горизонтальные линии-буферы и, при переходе в новое состояние (аналогично сдвигу окна вправо), будем считывать лишь 3 новых бита справа. Добавление каждого бита в строку-буфер сопровождается побитовым сдвигом строки на 1 влево, с отсечением крайнего левого бита. Сигналом для текущего автомата будет сумма верхней строки, средней строки с побитовым сдвигом влево на 3 и нижней строки с побитовым сдвигом на 6. Для наглядности процесс изображен на рисунке~\ref{opt-pattern}. 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{images/opti-pattern}
	\caption{Принцип оптимизированного вычисления входных сигналов с использованием буферов и побитовых сдвигов.}\label{opt-pattern}
\end{figure}

Результат аналогичен тому, что было получено в предыдущем разделе~\ref{simple-update}, но будет требоваться примерно в 3 раза меньше операций доступа. Получившийся результат особенно важен для нас, ведь обновление всех автоматов происходит каждый кадр. Полный код новой функции можно посмотреть в приложении \ref{code-update-optimised}.
% на самом деле это немного не так, но может опустить подробности 

\subsubsection{Правило перехода на языке шейдеров (HLSL)}
Обновление клеточных автоматов возможно полностью перенести в шейдеры. Каждая сетка с клеточным автоматом будет использовать свою текстуру и шейдер.

Для написания правила перехода на языке шейдеров необходимо решить три проблемы.
\begin{enumerate}
\item Получение информации о состояниях в предыдущий момент времени.
\item Соотнесение представления в битах (пикселях) с текстурой в трехмерном пространстве.
\item Обновление шейдера только при необходимости.
\end{enumerate}

Возьмем \verb|Custom Render Texture| из среды разработки \verb|Unity|. Данная текстура создана для того, чтобы её можно было обновлять с помощью шейдеров. 
%https://docs.unity3d.com/Manual/class-CustomRenderTexture.html 
% настройки
Первая проблема решается расширением языка HLSL, предоставляемым \verb|Custom Render Texture|. В фрагментном шейдере можно обратиться к переменной \verb|localTexcoord|, в которой хранится состояние текстуры на предыдущий момент отрисовки.

Вторая проблема также решается с использованием глобальных переменных: \verb|_CustomRenderTextureWidth|, предоставляющая ширину объекта в пространстве, и \verb|_CustomRenderTextureHeight|, возвращающая высоту текстуры.

Определим настройки \verb|Custom Render Texture| (рис.~\ref{CRT}). Установка параметра \verb|Wrap Mode| в значение \verb|Repeat| задаст периодические граничные условия для сетки. Другими словами, при обращении к пикселям по координатам, превышающим размерность текстуры, будут взяты пиксели с противоположной стороны сетки. Создадим пустой шейдер, код для которого опишем дальше. Настройка \verb|Update Mode| в значение \verb|On Demand| позволяет обновлять состояние текстуры по вызову функции из основной программы, что позволит получить полный контроль над обновлением автоматов.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{images/CustomRendererTexture}
	\caption{Настройка Custom Render Texture.}\label{CRT}
\end{figure}

% https://thebookofshaders.com/03/?lan=ru
Определим uniform-переменную: таблицу переходов размерности 512 (все возможные состояния рассматриваемого клеточного автомата).
\begin{minted}[fontsize=\footnotesize]{glsl}
	float _rule[512];
\end{minted}

Опишем функцию, возвращающую значение пикселя с заданным отступом в сетке относительно текущего клеточного автомата.
\begin{minted}[fontsize=\footnotesize]{glsl}
	float4 get(v2f_customrendertexture IN, int x, int y) : COLOR
	{
	   return tex2D(_SelfTexture2D, IN.localTexcoord.xy + 
	   	 fixed2(x / _CustomRenderTextureWidth, y / _CustomRenderTextureHeight));
	}
\end{minted}

Аналогично построению двоичного числа, последовательно, с левого верхнего угла, соберем биты входных сигналов для клеточного автомата в окрестности Мура порядка 2 и получим следующее состояние из таблицы перехода. Данный код необходимо выполнять в фрагментном шейдере~\cite{shader-pipeline}

\begin{minted}[fontsize=\footnotesize]{glsl}
	float getRule9(v2f_customrendertexture IN) : float
	{
	   int accumulator = 0;
	   for (int i = 2; i >= 0; i--) 
	   {
	       for (int j = 0; j <= 2; j++) 
	       {
	           int roundedAlpha = round(get(IN, i-1, j-1).a);
	           accumulator = (accumulator << 1) + roundedAlpha;
	       }
	   }
	   return _rule[accumulator];
	}
	
	float4 frag(v2f_customrendertexture IN) : COLOR
	{
	   return getRule9(IN);
	}
\end{minted}

Осталось объединить шейдер с основной программой. Пусть в массиве \verb|allRules| находятся правила для всех двумерных сеток. Тогда, 
опуская подробности, инициализацию текстуры можно произвести с помощью следующего кода

\begin{minted}[fontsize=\footnotesize]{csharp}
	customRenderTexture.material.SetFloatArray("_rule", allRules[screenInd]);
	customRenderTexture.Initialize();
\end{minted}

Пусть в массиве \verb|custormRenderTextures| содержатся все текстуры (сетки). Тогда, обновить каждый автомат можно, используя следующий фрагмент кода:

\begin{minted}[fontsize=\footnotesize]{csharp}
	foreach(var texture in customRenderTextures)
	{
	   texture.Update();
	}
\end{minted}

Запустим программу и увидим клеточные автоматы в динамике, как изображено на рис.~\ref{shvis}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{images/Shader-visualisation-2}
	\includegraphics[scale=0.7]{images/Shader-visualisation-1}
	\caption{Визуализация клеточных автоматов.}\label{shvis}
\end{figure}

\section{Генетический алгоритм для поиска клеточных автоматов}
Для получения приближенных результатов, воспользуемся генетическим алгоритмом~\cite{genetic-algo}. 
\textbf{Особи} "--- сетки с клеточными автоматами, \textbf{гены} "--- правила перехода для клеточных автоматов,
\textbf{приспособленность} особи "--- суммарная степень совпадения для каждой окрестности ячейки клеточного автомата некоторому целевому изображению (паттерну), 
воспроизведение которого и будет являться целью каждого эксперимента. 


\subsection{Подсчет приспособленности}
Для правильной работы генетического алгоритма, нам нужно различать <<полезные>> особи от <<ненужных>>. Для этого определим приспособленность особи.
Приспособленностью особи будем считать процент совпадения фрагментов полученного изображения на сетке с заданным перед началом эксперимента паттерном. Таким образом, мы проверяем окрестность каждого пикселя сетки на совпадение с заданным паттерном.

При подсчете приспособленности учитывается количество допустимых ошибок при сравнении с паттерном. Если число пикселей, не совпадающих с целевым изображением, превышает порог, мгновенно переходим на следующую итерацию. В противном случае, если X "--- максимальное количество допустимых ошибок, а Y "--- число несовпадений в паттерне, тогда к ответу прибавим 
$(1 + X - Y)/(X + 1)$.
Добавляя такой параметр, мы намеренно рискуем получить искаженный результат, не совпадающий полностью с паттерном, но зачастую такая мера необходима для значительного уменьшения времени сходимости к приемлемому результату. Однако выбранная нами формула стимулирует автомат находить результат без ошибок, что частично компенсирует этот недостаток.

Также необходимо учесть, что мы можем искать совпадение не с единственным изображением, а с целым набором, как показано на изображении~\ref{ptn-cubes}. В таком случае, на каждой итерации, при проверке совпадения окрестности с паттерном, к аккумулятору в функции приспособленности добавится максимальное значение по всем паттернам.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/Patterns-many-cube}
	\caption{Пример случая, когда проверяется совпадение с несколькими паттернами}\label{ptn-cubes}
\end{figure}

Полный код функции приведен в приложении~\ref{fitness-calc-normal}.

В идеальном случае, нам хотелось бы высчитать некоторую нормализованную функцию приспособленности, которая бы для сетки любой размерности и любого набора паттернов давала бы значение в диапазоне от 0 до 1 (или 100, для наглядности). Подобная функция учитывала бы максимально возможное количество изображений на паттерне. Таким образом мы могли бы поделить количество вхождений паттерна в изображении на максимально возможное и измерить процент совпадения. В реальности же это достижимо только с помощью полного перебора всей сетки, что в самом простом случае, без оптимизаций, при размере изображения $64\times64$, требовало бы произвести $2^{64\times64}$ подсчетов приспособленности. Поэтому для упрощения, будем считать значение приспособленности равным 100 если изображение полностью состоит из паттернов без пересечения. Например, если исходное изображение имеет размерность $64\times64$, а паттерн "--- $4\times4$, то на изображении возможно разместить $(64\times64) / (4\times4) = 256$ паттернов.

Подведем подсчет приспособленности на последних итерациях и сделаем возможным устанавливать количество итераций перед процессом эволюции. Между двумя подсчетами приспособленности происходит ровно одно обновление клеточных автоматов на сетке.

Если запустить программу с профилировщиком, можно заметить, что самым затратным по времени местом в программе является именно подсчет приспособленности (см. рис.~\ref{fitness-calc-bad}). Это не удивительно, ведь для каждого пикселя сетки приходится проверять соответствие окрестности с заданным паттерном, а с увеличением его размера в X раз, в столько же раз увеличивается и количество операций доступа при подсчете приспособленности. Далее попробуем оптимизировать этот процесс.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{images/Profiler-bad}
	\caption{Фрагмент окна профилировщика. Видимые подъемы связаны с процессом подсчета приспособленности}\label{fitness-calc-bad}
\end{figure}

\subsection{Подсчет приспособленности на основе данных с GPU}
Попробуем снизить нагрузку во время подсчета приспособленности клеточных автоматов на сетке за счет переноса обновления сетки с процессора на видеокарту. Так как визуализация клеточных автоматов с помощью шейдеров уже готова, достаточно считывать изображение перед каждым подсчетом приспособленности.

После считывания, переведем пиксели цвета изображения в числа 0 и 1 и воспользуемся готовой функцией подсчета приспособленности.
\begin{minted}[fontsize=\footnotesize]{csharp}
	private float CalculateFitness(Texture2D texture2D, Pattern[] patterns)
	{
	  texturePixels = texture2D.GetPixels32();
	  return CalculateFitness(texturePixels, texture2D.width, texture2D.height, patterns);
	}
	
	byte[] texturePix = null;
	private float CalculateFitness(Color32[] texturePixels, int texW, 
		int texH, Pattern[] patterns)
	{
	  var texSize = texW * texH;
	  texturePix = new byte[texSize];
	  for (int i = 0; i < texSize; i++)
	  {
	      texturePix[i] = texturePixels[i].a;
	  }
	  return CalculateFitness(texturePix, texW, texH, patterns);
	}
\end{minted}

Вопреки ожиданиям, это не ускорило программу. Это можно объяснить тем, что скорость передачи данных с видеопамяти в оперативную память крайне медленная~\cite{gpu2cpu}.

\subsection{Оптимизация подсчета приспособленности}
Воспользуемся оптимизацией, описанной в разделе~\ref{signal-optimized}, с отличием в том, что паттерн может быть произвольного размера. Для начала переведем двоичные числа, образованные последовательным считыванием слева направа каждой строкой паттерна, в десятичное число и сохраним эту информацию во вспомогательном массиве. Данные числа останутся неизменными. Далее, проведем сравнение битов сетки клеточного автомата и паттерна.

Повторим действия, описанные в разделе~\ref{signal-optimized} для сетки клеточного автомата. Аналогично, переведем двоичные числа, образованные битами, в десятичные и запишем в массив. Таким образом, размерность массива по обоим измерениям будет совпадать с полученным для паттерна. 

Имея два двоичных числа в десятичном представлении, мы можем получить новое двоичное число, которое будет состоять исключительно из различающихся битов в двух исходных числах. Делается это с помощью операции XOR (сложение по модулю 2). В языке программирования \verb|C#| она обозначается как \verb|^|. 

В результате, мы получаем новое десятичное число, количество единиц в двоичном представлении которого "--- количество битов в окрестности ячейки, \textbf{не} совпадающих с паттерном. Для быстрого подсчета единиц, воспользуемся параллельным SWAR-алгоритмом, подробную информацию про который можно посмотреть в источнике~\cite{bithacks}.

После подсчета разницы, для каждого числа-буфера, полученного для сетки, используем побитовый сдвиг влево с выбрасыванием крайнего левого бита (используя бинарное <<И>>) и добавим новое число справа. Повторим алгоритм, пока не дойдем до конца сетки.

Далее вставлен основной фрагмент описанного кода. Полный код доступен в приложении~\ref{fitness-calc-optimised}.

\begin{minted}[fontsize=\footnotesize]{csharp}
for (short j = 0; j < textureWidth; j++)
 {
   cornerPixel = j + i * textureWidth;
   for (byte p = 0; p < patterns.Length; p++)
   {
       curErr[p] = 0;
   }
   int minErrors = patternErrors + 1;
   
   for (byte k = 0; k < patternHeight; k++)
   {
     int ind = (qOffset + k) % patternHeight;
     screenLine = screenLines[ind];
     newErr = patternLines[k] ^ screenLine;

     for (byte p = 0; p < patterns.Length; p++)
     {
       newErr = newErr - ((newErr >> 1) & 0x55555555);
       newErr = (newErr & 0x33333333) + ((newErr >> 2) & 0x33333333);
       curErr[p] += (((newErr + (newErr >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
     }

     screenLine <<= 1;
     if (screenLine >= patternCycle) screenLine -= patternCycle;
     nextPixInd = (((i + k) % textureHeight) * textureWidth) + (j + patternWidth) % textureWidth;
     screenLine += texturePixels[nextPixInd];
     
     screenLines[(qOffset + k) % patternHeight] = (screenLine);
   }
   
   for (byte p = 0; p < patterns.Length; p++)
   {
       if (curErr[p] < minErrors) minErrors = curErr[p];
   }
   fitness += minErrors <= patternErrors ? 
    (1 + patternErrors - minErrors) * 1f / (patternErrors + 1) : 0;
}
\end{minted}

Даже с учетом подобных и ранее описанных оптимизаций в разделе~\ref{signal-optimized}, данный этап остается самым высоко нагруженным. Поэтому для пользователя программы сделана возможность определить количество подсчетов приспособленности на каждом цикле эволюции.

\subsection{Эволюция}\label{evolution}
Этап эволюции начинается после завершения подсчетов приспособленности клеточных автоматов на последних кадрах. На основании полученных данных будет отбираться половина особей с наивысшей приспособленностью, из них случайным образом будут созданы пары, каждая из которых создаст два потомка. Правила переходов для потомков формируются из генов родителей, которые также сохраняются до следующего этапа эволюции. В работе будут рассмотрены два вида скрещивания.

Для первого вида скрещивания выберем случайный номер бита в генах (правила перехода длиной 512), будем называть его <<разделителем>>. Все биты первого родителя до разделителя станут основой для правила перехода первого дочернего клеточного автомата, все биты с номером $\geq$ разделитель возьмутся из второго родителя. Для второго дочернего клеточного автомата, до разделителя берутся биты из второго родителя, а после "--- из первого.
% вставить картинку

Второй вид скрещивания реализован с помощью случайного выбора родителя для \textbf{каждого} бита.
% вставить картинку

После скрещивания случайным образом мутируем гены автоматов, полученных после этапа эволюции. В случае клеточных автоматов с возможными состояниями 0 и 1, 0 меняется на 1 и наоборот. Разрешим до X мутаций, а вероятность того что выбранный клеточный автомат мутирует "--- Y. Оба параметра настраиваются пользователем перед экспериментом.

\subsection{Сбор статистики и визуализация результатов}
Перед началом эксперимента по поиску клеточного автомата, воспроизводящего паттерн, случайным образом создадим идентификационный номер (ID) эксперимента. Название сопутствующих файлов со статистикой будет содержать в суффиксе ID эксперимента. Во время исполнения эксперимента, можно наблюдать за графиком приспособленности (рис.~\ref{fitness-history}) и генофондом популяции (рис.~\ref{genofond-simple}-\ref{genofond-simple-end}).

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{images/fitness-history}
	\caption{Динамически построенный график приспособленности на эксперименте. Подробные числовые значения доступны в файлах с префиксом <<FH->>}\label{fitness-history}
\end{figure}
% генофонд и график приспособленности

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.45]{images/geno-start}
	\caption{Генофонд популяции на старте. По оси X "--- биты генов от 0 до 512, по оси Y "--- клеточные автоматы в популяции (256)}\label{genofond-simple}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{images/geno-end}
	\caption{Генофонд популяции в автомате с высокой приспособленностью. Можно заметить, что некоторые биты гена остаются неизменными у всех особей}\label{genofond-simple-end}
\end{figure}

После каждого эксперимента статистика записывается в файлы. Полная информация о настройках и результатах (средняя приспособленность, время, количество итераций эволюции) эксперимента, максимальные и средние значения приспособленности на каждой итерации, опорные биты (см. раздел \ref{pivot-bits}). Данные файлы расположены в папке:

\verb|{Расположение_проекта}/Assets/SimulationData/|

После завершения эксперимента, в файл также записываются и правила переходов в виде генов. Файл расположенный в пути:

\verb|{Расположение_проекта}/Assets/SimulationData/Genes/| 

Каждый файл имеет название \verb|G-{Имя_Паттерна}-{IDэксперимента}.txt|. 

В нем ген каждого клеточного автомата записывается в новой строке, и, соответственно, количество строк в файле определяется числом клеточных автоматов в проведенном эксперименте.

Для просмотра клеточных автоматов после эксперимента создана дополнительная сцена в Unity с названием \foreignlanguage{English}{GeneVisualisation}. В основном, она отличается от главной сцены тем, что в ней имеется одна большая сетка размерности $1024\times1024$ и отключена возможность эволюции автоматов. Для считывания файла с генами создан дополнительный скрипт. В редакторе необходимо выбрать файл с данными генов, созданный автоматически после эксперимента. Запустив сцену, можно увидеть, как сетка меняет свое изначальное изображение~\ref{GeneVisualisation}, используя правила перехода из файла. Для переключения между всеми правилами в наборе, необходимо нажать стрелку влево или стрелку вправо на клавиатуре.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{images/GeneVisualisation}
	\caption{Сцена для визуализации клеточных автоматов после эксперимента. Данный результат получен при попытке воссоздать паттерн <<квадрат $3\times3$ с рамкой в 1 пиксель противоположного цвета>>.}\label{GeneVisualisation}
\end{figure}


\section{Эксперименты}
Данный раздел будет посвящен проведению экспериментов для сбора статистики, с помощью которой в дальнейшем можно выявить зависимость между параметрами эксперимента и скоростью нахождения клеточных автоматов, удовлетворяющих заданным условиям. 

Перед выполнением экспериментов были поставлены следующие вопросы. Возможно ли найти такие параметры модели, которые универсально для любого паттерна будут приводить к быстрому нахождению клеточного автомата, моделирующего его? Если нет, то возможно ли подобрать заранее параметры, наиболее подходящие для заданного паттерна? 

\subsection{Конфигурация параметров эксперимента}
Перед началом эксперимента в окне редактора (см. рис.~\verb|Unity|~\ref{sim-settings}) можно определить следующие значения:
\begin{itemize}
\item \verb|Update Period| "--- минимальное время между кадрами, необходимое перед следующим обновлением автомата;
\item \verb|Screen Size In Pixels| "--- размер квадратной сетки (в количестве ячеек) по одному измерению;
\item \verb|Virtual Screens In Simulation| "--- (кратное 4) количество клеточных автоматов в эксперименте;
\item \verb|Screens In Simulation| "--- количество автоматов, для которых будет действовать визуализация;
\item \verb|Time To Evolution| "--- время до первого подсчета приспособленности автоматов;
\item \verb|Mutation Percent| "--- вероятность, определенная для каждого автомата, того, что он мутирует;
\item \verb|Mutate Bits Up To| "--- X, количество битов, которые могут мутировать: от 1 до X;
\item \verb|Pivot Bit Fitness Threshold| "--- пороговое значение приспособленности, начиная с которого будут отслеживаться опорные биты (подробнее в разделе~\ref{pivot-bits});
\item \verb|Write To Global Pivot Bits| "--- записывать ли опорные биты в данном эксперименте в файл (подробнее в разделе~\ref{pivot-bits});
\item \verb|Fitness Calculations Needed| "--- количество подсчетов приспособленности перед этапом эволюции;
\item \verb|MS Fitness Threshold| "--- пороговое значение приспособленности для завершения эксперимента и перехода к следующему;
\item \verb|MS Calculations After Threshold| "--- дополнительное количество этапов эволюции после достижения порога (проверка, может ли клеточный автомат развиваться дальше, даже после достижения указанного порога);
\item \verb|Evolution Step Limit| "--- пороговое значение количества этапов эволюции для завершения эксперимента и перехода к следующему;
\item \verb|Cross Separation| "--- проводить ли скрещивание на основе разделителя (подробнее в разделе~\ref{evolution}).
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.85]{images/sim-settings}
	\caption{Конфигурация эксперимента.}\label{sim-settings}
\end{figure}

\subsection{Поиск закономерностей в таблице переходов}\label{pivot-bits}
Предположим, что для любого правила клеточного автомата существуют биты, являющиеся наиболее важными при формировании определенного паттерна. Далее, для удобства, будем называть эти биты <<опорными>>. Тогда, для их нахождения создадим дополнительный массив, в котором будем хранить <<ценность>> бита. Определим её следующим образом:
\begin{enumerate}
\item К значению ценности бита прибавим 1, если бит гена равен единице, и $-1$ в противном случае.
\item Если приспособленность автомата меньше средней, то взять результат из п.1 и домножить на $-1$.
\item Итоговая ценность бита берется как значение по модулю от ценности бита.
\end{enumerate}
Будем считать \textbf{опорными} те биты, значение по модулю которых превосходит среднее значение по модулю ценности среди всех битов правила.

Введенные нами алгоритм объясняется предположением, что в правиле найдутся биты, которые будут присутствовать только в автоматах с высокой приспособленностью. Добавим дополнительное ограничение на то, что подсчет опорных битов будет вестись лишь начиная с заданного процента приспособленности. Для наглядности будем отображать опорные биты на генофонде клеточных автоматов отдельным (оранжевым) цветом, как на изображении~\ref{genofond-pivot}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{images/genofond-pivot}
	\caption{Генофонд автоматов. Оранжевым цветом отображаются опорные биты.}\label{genofond-pivot}
\end{figure}

Однако, само по себе нахождение опорных битах в одном эксперименте не позволит сделать выводы о закономерностях в правилах. Для того чтобы узнать, сохраняются ли опорные биты для повторных попыток найти правила, воспроизводящих заданный паттерн, необходимо найти <<глобальные опорные биты>>. После каждого эксперимента запишем все опорные биты в новую строку в файл. Перед началом следующего эксперимента считаем строки с опорными битами и прибавим $+1$ к каждому глобальному значению ценности бита. Все биты, глобальное значение ценности которых превышает количество множеств опорных битов, будут считаться глобальными опорными битами. Отобразим их на генофонде отдельным (бирюзовым) цветом, как на изображении~\ref{genofond-global-pivot}.

Анализ результатов и выводы будут отражены в дипломной работе.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{images/genofond-global-pivot}
	\caption{Генофонд автоматов. Бирюзовым цветом отображаются глобальные опорные биты.}\label{genofond-global-pivot}
\end{figure}

\subsection{Описание экспериментов}\label{description}
В настоящей работе было проведено 436 экспериментов над паттернами~\ref{patterns}:

\begin{itemize}
\item 93 над <<крестом $5\times5$ с одной ошибкой>>;
\item 40 над <<елкой $5\times5$ с одной ошибкой>> (в трех конфигурациях);
\item 44 над <<елкой $5\times5$ с двумя ошибками>> (в двух конфигурациях);
\item 236 над <<квадратом $3\times3$ и рамкой 1 пиксель противоположного цвета с двумя ошибками>> (в пяти конфигурациях);
\item 12 над <<крестом $5\times5$ и рамкой 1 пиксель противоположного цвета с четырьмя ошибками>> (в трех конфигурациях);
\item 11 над <<повернутой в 4 стороны елкой $5\times5$ с одной ошибкой>>.
\end{itemize}

\begin{figure}[h]
	\centering
	
	\includegraphics[scale=0.19]{images/pattern-cross}
	
	\includegraphics[scale=0.2]{images/pattern-elka}
	
	\includegraphics[scale=0.2]{images/Patterns-many-cube}
	
	\includegraphics[scale=0.16]{images/Pattern-cross-border}
	
	\includegraphics[scale=0.2]{images/Pattern-elka-sym}
	
	\caption{Паттерны: <<крест $5\times5$>>, <<елка $5\times5$>>, <<квадрат $3\times3$ и рамка 1 пиксель противоположного цвета>>, 
	<<крест $5\times5$ и рамка 1 пиксель противоположного цвета>>, <<повернутая в 4 стороны елка $5\times5$>> .}\label{patterns}
\end{figure}

\newpage
%===========================================
% Раздел "Заключение"
\conclusion
В результате преддипломной практики было создано полноценное приложение для нахождения двумерных клеточных автоматов первого порядка, воспроизводящих заданный паттерн. Полученное приложение применимо для проведения экспериментов по подбору наилучших параметров для быстрого и эффективного (по значению приспособленности) поиска заданных клеточных автоматов. Полученные результаты можно использовать и для других клеточных автоматов: высшего порядка, с большим числом состояний, с другим множеством начальных состояний.

%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением

\appendix

\section{Код оптимизированной функции переходов}\label{code-update-optimised}
\lstinputlisting{code/OptimisedUpdateCA.cs}
\section{Код функции подсчета приспособленности}\label{fitness-calc-normal}
\lstinputlisting{code/PatternFitness.cs}
\section{Оптимизированный подсчет паттерна}\label{fitness-calc-optimised}
\lstinputlisting{code/PatternFitnessOptimised.cs}

\end{document}
