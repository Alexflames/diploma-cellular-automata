\documentclass[bachelor, och, pract, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{longtable}
\usepackage{array}
\usepackage{xcolor}
\usepackage[english,russian]{babel}

\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Безымянная дипломная работа}

% Курс
\course{4}

% Группа
\group{451}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Григорьева Алексея Александровича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н., доцент} % степень, звание
\chname{А.\,С.\,Иванов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент} %должность, степень, звание
\saname{М.\,С.\,Семенов}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{доцент}
\paname{М.\,С.\,Семенов}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{8}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{преддипломная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{4}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{30.04.2020}
\practFinish{27.05.2020}

% Год выполнения отчета
\date{2020}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations
%\begin{description}
    %\item \foreignlanguage{english}{EVM} "--- %\foreignlanguage{english}{Ethereum Virtual Machine};
%\end{description}

% Раздел "Определения". Может отсутствовать в работе
\definitions
Паттерн "---

Эксперимент (в контексте данной работы) "--- процесс поэтапной эволюции клеточных автоматов с целью достижения максимального совпадения воспроизводимых ими результатов заданным наперед паттернам.


% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro
Осознание

Эксперименты по оптимизации проводились для двумерных клеточных автоматов первого порядка, с возможными состояниями 0 и 1. Следующее состояние клеточного автомата определяется 9 соседними автоматами на решетке включая данный или, другими словами, окрестностью Мура порядка 2. %https://mathworld.wolfram.com/MooreNeighborhood.html
Тип автоматов выбран не случайно: количество возможных правил, описывающих их, равно $2^{512}$, %https://www.stephenwolfram.com/publications/cellular-automata-complexity/pdfs/two-dimensional-cellular-automata.pdf
что гарантирует невозможность перебора. %ссылка на переборы?, лол
Более того, не существует и общего аналитического решения для получения произвольного изображения, при условии что изначальна двумерная сетка задана случайными значениями.
У выбранных в данной работе типов клеточных автоматов также есть преимущества, связанные с возможностью оптимизации алгоритмов. Многие из описанных далее результатов возможно перенести на случай клеточных автоматов \verb|N|-го порядка, % так ли это? Если да, нужно цитировать
а также для клеточных автоматов с увеличенным количеством состояний или иными правилами обновления.

Целью данной работы является 

\section{Окружение для проведения экспериментов}
В данном разделе

\subsection{Среда разработки}
Поставленную задачу решено выполнить с использованием среды разработки \verb|Unity|. Такой выбор основан удобствами, предоставляемыми средой. В частности, на выбор повлияли следующие преимущества:
\begin{itemize}
\item быстрая и многофункциональная работа с графикой посредством готовых функций и визуального проектирования;
\item профессиональные инструменты для отладки производительности программы;
\item наглядность результата программы.
\end{itemize}

Программный код написан на языке \verb|C#|.


\subsection{Реализация клеточного автомата}
Опишем правила перехода для двумерного клеточного автомата первого порядка. При подсчете входного сигнала будут учитываться как и состояние данного автомата, 
так и состояния восьми соседних автоматов в окрестности мура порядка 2, для подсчета берутся значения с последней итерации. Возьмем самый простой случай: автомат может принимать значения 0 и 1. Таким образом, возможны $2^9=512$ вариантов входных сигналов. Отсюда и берется упомянутое ранее количество всевозможных правил для данных клеточных автоматов, $2^{512}$.

Каждый клеточный автомат будет расположен на двумерной сетке. %упомянуть периодичные граничные условия 
В границах одной сетки все автоматы имеют единые правила перехода. Ради прозрачности процесса и наглядности результатов, эксперимент проводится полностью в реальном времени: в каждую единицу времени все автоматы на всех сетках переходят в новое состояние, определенное входными сигналами и правилами перехода.

В качестве визуализации клеточных автоматов в \verb|Unity| можно использовать шейдеры. Плюс этого подхода заключается в том, что компьютер не будет тратить ресурсы оперативной памяти для визуализации автоматов, и вся нагрузка на это отдается видеокарте. 

\subsubsection{Правило перехода}
Создадим простейшую реализацию подсчета таблицы перехода для каждого клеточного автомата, и обновления по ней. 
Для избежания лишних затрат памяти, в основной части программы заранее созданы массивы, для временного хранения состояния автомата на следующем шаге, чтобы полученный результат не влиял на соседние автоматы в данный момент.

Создадим цикл, который будет выполняться на двумерной сетке с клеточными автоматами и размерностью \verb|screenSizeInPixels| по X и Y.
\begin{minted}[fontsize=\footnotesize]{csharp}
	var nextCAField = nextVirtualScreens[ind];
	var screen2DSize = screenSizeInPixels * screenSizeInPixels;
	for (short i = 0; i < screenSizeInPixels; i++)
	{
	   for (short j = 0; j < screenSizeInPixels; j++)
	   {
	       int signal = 0;
	       for (short k = 0; k < 3; k++)
	       {
	           for (short m = 0; m < 3; m++)
	           {
	               signal += CAField[
	                   (screen2DSize + screenSizeInPixels * i + j
	                   + screenSizeInPixels * (k - 1) + (m - 1)) 
	                   % (screen2DSize)] << (k * 3 + m);
	           }
	       }
	       nextCAField[i * screenSizeInPixels + j] = (byte)allRules[ind][signal];
	   }
	}
	
	for (short i = 0; i < screen2DSize; i++)
	{
	   CAField[i] = nextCAField[i];
	}
\end{minted}

\subsubsection{Оптимизированное вычисление входных сигналов}


\subsubsection{Правило перехода на языке шейдеров (HLSL)}
Обновление клеточных автоматов возможно полностью перенести в шейдеры. Каждая сетка с клеточным автоматом будет использовать свою текстуру и шейдер.


Для написания правила перехода на языке шейдеров необходимо решить три проблемы:
\begin{enumerate}
\item получение информации о состояниях в предыдущий момент времени;
\item соотнесение представления в битах (пикселях) с текстурой в трехмерном пространстве;
\item обновление шейдера только при необходимости.
\end{enumerate}

Возьмем \verb|Custom Render Texture| из среды разработки \verb|Unity|, который создан для отрисовки текстуры с помощью шейдеров. 
%https://docs.unity3d.com/Manual/class-CustomRenderTexture.html 
% настройки
Первая проблема решается расширением языка HLSL, предоставляемой \verb|Custom Render Texture|. В фрагментном шейдере можно обратиться к переменной \verb|localTexcoord|, в которой хранится состояние текстуры на предыдущий момент отрисовки.

Вторая проблема также решается глобальными переменными \verb|_CustomRenderTextureWidth|, предоставляющая ширину объекта в пространстве и \verb|_CustomRenderTextureHeight|, возвращающая высоту.

Определим настройки \verb|Custom Render Texture|~\ref{CRT}. Установка \verb|Wrap Mode| в значение \verb|Repeat| задаст периодические граничные условия для сетки. Другими словами, при обращении к пикселям по координатам, превышающим размерность текстуры, будут взяты пиксели с противоположной стороны сетки. Создадим пустой шейдер, код для которого опишем дальше. Настройка \verb|Update Mode| в значение \verb|On Demand| позволяет обновлять состояние текстуры по вызову функции из основной программы, что позволит получить полный контроль над обновлением автоматов.
% скриншот с настройкой внутри Юнити
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{images/CustomRendererTexture}
	\caption{Настройка Custom Render Texture.}\label{CRT}
\end{figure}

% https://thebookofshaders.com/03/?lan=ru
Определим uniform-переменную: таблицу переходов размерности 512 (все возможные состояния рассматриваемого клеточного автомата).
\begin{minted}[fontsize=\footnotesize]{glsl}
	float _rule[512];
\end{minted}

Опишем функцию, возвращающую значение пикселя с заданным отступом в сетке относительно текущего клеточного автомата.
\begin{minted}[fontsize=\footnotesize]{glsl}
	float4 get(v2f_customrendertexture IN, int x, int y) : COLOR
	{
	   return tex2D(_SelfTexture2D, IN.localTexcoord.xy + 
	   	 fixed2(x / _CustomRenderTextureWidth, y / _CustomRenderTextureHeight));
	}
\end{minted}

Аналогично построению двоичного числа, последовательно, с левого верхнего угла, соберем биты входных сигналов для клеточного автомата в окрестности Мура порядка 2 и получим следующее состояние из таблицы перехода.

\begin{minted}[fontsize=\footnotesize]{glsl}
	float getRule9(v2f_customrendertexture IN) : float
	{
	   int accumulator = 0;
	   for (int i = 2; i >= 0; i--) 
	   {
	       for (int j = 0; j <= 2; j++) 
	       {
	           int roundedAlpha = round(get(IN, i-1, j-1).a);
	           accumulator = (accumulator << 1) + roundedAlpha;
	       }
	   }
	   return _rule[accumulator];
	}
	
	float4 frag(v2f_customrendertexture IN) : COLOR
	{
	   return getRule9(IN);
	}
\end{minted}

Осталось объединить шейдер с основной программой. Пусть в массиве \verb|allRules| находятся правила для всех двумерных сеток. Тогда, 
опуская подробности, инициализацию текстуры можно произвести с помощью следующего кода

\begin{minted}[fontsize=\footnotesize]{csharp}
	customRenderTexture.material.SetFloatArray("_rule", allRules[screenInd]);
	customRenderTexture.Initialize();
\end{minted}

Пусть в массиве \verb|custormRenderTextures| содержатся все текстуры (сетки). Тогда, обновить каждый автомат можно, используя следующий фрагмент кода:

\begin{minted}[fontsize=\footnotesize]{csharp}
	foreach(var texture in customRenderTextures)
	{
	   texture.Update();
	}
\end{minted}

\section{Генетический алгоритм для поиска клеточных автоматов}
В качестве инструмента для получения приближенного результата будет взят генетический алгоритм. 
\textbf{Особи} "--- клеточные автоматы, \textbf{гены} "--- правила перехода,
\textbf{приспособленность} особи "--- степень совпадения некоторой окрестности клеточного автомата некоторому целевому изображению (паттерн), 
воспроизведение которого и будет являться целью каждого эксперимента. 

Для эволюции будут отбираться половина особей с наивысшей приспособленностью, из них случайным образом будут созданы пары, каждая из которых создаст
два потомка. Правила переходов для потомков формируются из генов родителей, которые так же сохраняются до следующего этапа эволюции. В работе будут 
рассмотрены два вида скрещивания.

Для первого вида скрещивания выберем случайный номер бита в генах (правила перехода длиной 512), будем называть его <<разделителем>>. Все биты первого родителя до разделителя станут основой для правила перехода первого дочернего клеточного автомата, все биты с номером $\geq$ разделитель возьмутся из второго родителя. Для второго дочернего клеточного автомата, до разделителя берутся биты из второго родителя, а после "--- из первого.

% вставить картинку

Второй вид скрещивания основывается на случайном выборе родителя для каждого бита.

% вставить картинку

\subsection{Подсчет приспособленности}
....

При подсчете приспособленности учитывается количество допустимых ошибок в паттерне. Добавляя такой параметр, мы намеренно рискуем получить искаженный результат, но зачастую такая мера необходима для значительного уменьшения времени сходимости.

\begin{minted}[fontsize=\footnotesize]{csharp}
	foreach(var texture in customRenderTextures)
	{
	   texture.Update(); blahblahblah
	}
\end{minted}

В идеальном случае, нам хотелось бы высчитать некоторую нормализованную функцию приспособленности, которая бы для любой сетки и набора паттернов давала бы значение в диапазоне от 0 до 1 (или 100, для наглядности). Подобная функция учитывала бы максимально возможное количество изображений на паттерне. Таким образом мы могли бы поделить количество вхождений паттерна в изображение на максимально возможное, и измерить процент совпадения. В реальности же это достижимо только с помощью полного перебора всей сетки, что в самом простом случае, при размере изображения $64\times64$ без оптимизаций требовало бы произвести $2^{64\times64}$ подсчетов приспособленности. Поэтому, для упрощения, будем считать значение приспособленности равным 100 если на изображение полностью состоит из паттернов без пересечения. Например, если исходное изображение имеет размерность $64\times64$, а паттерн "--- $4\times4$, то на изображении возможно разместить $64\times64 / 4\times4 = 256$ паттернов.


Подведем подсчет приспособленности на последних итерациях, и сделаем возможно устанавливать количество итераций перед процессом эволюции. Между двумя подсчетами приспособленности происходит ровно одно обновление клеточных автоматов на сетке.

Если запустим программу с профилировщиком, можно заметить, что самым затратным по времени местом в программе является именно подсчет приспособленности~\ref{fitness-calc-bad}. Это не удивительно, ведь для каждого пикселя сетки приходится проверять соответствие окрестности с заданным паттерном, а с увеличением его размера в X раз, в столько же раз увеличивается и количество операций доступа при подсчете приспособленности. Далее попробуем оптимизировать этот процесс.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{images/Profiler-bad}
	\caption{Фрагмент окна профилировщика. Видимые подъемы связаны с процессом подсчета приспособленности}\label{fitness-calc-bad}
\end{figure}

\subsection{Подсчет приспособленности на основе данных с GPU}


\subsection{Оптимизация подсчета приспособленности}

\subsection{Эволюция}
Что-то

\subsection{Сбор статистики и визуализация результатов}
Что-то

После завершения эксперимента, правила переходов в виде генов записываются в файл\label{gene-file}, расположенный в пути \verb|{Расположение_проекта}/Assets/SimulationData/Genes/| и имеющий название \verb|G-{Имя_Паттерна}-{IDэксперимента}.txt|. Каждый ген записывается в новой строке, и, соответственно, количество строк в файле определяется числом двумерных сеток в проведенном эксперименте.

Для просмотра клеточных автоматов после эксперимента, создана дополнительная сцена в Unity с названием \foreignlanguage{English}{GeneVisualisation}. В основном, она отличается от главной сцены тем, что в ней имеется одна большая сетка размерности $1024\times1024$, и отключена возможность эволюции автоматов. Для считывания файла с генами создан дополнительный скрипт. В редакторе необходимо выбрать файл с данными~\ref{gene-file}, созданный автоматически после эксперимента. Запустив сцену, можно увидеть, как сетка меняет свое изначальное изображение, используя правила перехода из файла~\ref{GeneVisualisation}. Для переключения между всеми правилами в наборе, необходимо нажать стрелку влево или стрелку вправо на клавиатуре.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{images/GeneVisualisation}
	\caption{Сцена для визуализации клеточных автоматов после эксперимента. Данный результат получен при попытке воссоздать паттерн <<квадрат $3\times3$ с рамкой в 1 пиксель противоположного цвета.}\label{GeneVisualisation}
\end{figure}


\section{Эксперименты}
Данный раздел будет посвящен поиску зависимостей между параметрами эксперимента и скоростью нахождения клеточных автоматов, удовлетворяющих заданным условиям. Возможно ли найти такие параметры модели, которые универсально для любого паттерна будут приводить к быстрому нахождению клеточного автомата, моделирующего его? Если нет, то возможно ли подобрать заранее параметры, наиболее подходящие для заданного паттерна?

\subsection{Поиск закономерностей в таблице перехода}
Предположим, что для любого паттерна существуют выбранные биты


Более того, можно предположить, что клеточные автоматы в разных экспериментах имеют сходства в правилах перехода. 

\newpage
%===========================================
% Раздел "Заключение"
\conclusion
Заключение

%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением

\appendix

\section{Листинг программы}\label{pril-1}
?

\end{document}
